# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import pulumi
import pulumi.runtime

class HostVirtualSwitch(pulumi.CustomResource):
    """
    The `vsphere_host_virtual_switch` resource can be used to manage vSphere
    standard switches on an ESXi host. These switches can be used as a backing for
    standard port groups, which can be managed by the
    [`vsphere_host_port_group`][host-port-group] resource.
    
    For an overview on vSphere networking concepts, see [this
    page][ref-vsphere-net-concepts].
    
    [host-port-group]: /docs/providers/vsphere/r/host_port_group.html
    [ref-vsphere-net-concepts]: https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.networking.doc/GUID-2B11DBB8-CB3C-4AFF-8885-EFEA0FC562F4.html
    """
    def __init__(__self__, __name__, __opts__=None, active_nics=None, allow_forged_transmits=None, allow_mac_changes=None, allow_promiscuous=None, beacon_interval=None, check_beacon=None, failback=None, host_system_id=None, link_discovery_operation=None, link_discovery_protocol=None, mtu=None, name=None, network_adapters=None, notify_switches=None, number_of_ports=None, shaping_average_bandwidth=None, shaping_burst_size=None, shaping_enabled=None, shaping_peak_bandwidth=None, standby_nics=None, teaming_policy=None):
        """Create a HostVirtualSwitch resource with the given unique name, props, and options."""
        if not __name__:
            raise TypeError('Missing resource name argument (for URN creation)')
        if not isinstance(__name__, basestring):
            raise TypeError('Expected resource name to be a string')
        if __opts__ and not isinstance(__opts__, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')

        __props__ = dict()

        if not active_nics:
            raise TypeError('Missing required property active_nics')
        elif not isinstance(active_nics, list):
            raise TypeError('Expected property active_nics to be a list')
        __self__.active_nics = active_nics
        """
        The list of active network adapters used for load
        balancing.
        """
        __props__['activeNics'] = active_nics

        if allow_forged_transmits and not isinstance(allow_forged_transmits, bool):
            raise TypeError('Expected property allow_forged_transmits to be a bool')
        __self__.allow_forged_transmits = allow_forged_transmits
        """
        Controls whether or not the virtual
        network adapter is allowed to send network traffic with a different MAC
        address than that of its own. Default: `true`.
        """
        __props__['allowForgedTransmits'] = allow_forged_transmits

        if allow_mac_changes and not isinstance(allow_mac_changes, bool):
            raise TypeError('Expected property allow_mac_changes to be a bool')
        __self__.allow_mac_changes = allow_mac_changes
        """
        Controls whether or not the Media Access
        Control (MAC) address can be changed. Default: `true`.
        """
        __props__['allowMacChanges'] = allow_mac_changes

        if allow_promiscuous and not isinstance(allow_promiscuous, bool):
            raise TypeError('Expected property allow_promiscuous to be a bool')
        __self__.allow_promiscuous = allow_promiscuous
        """
        Enable promiscuous mode on the network. This
        flag indicates whether or not all traffic is seen on a given port. Default:
        `false`.
        """
        __props__['allowPromiscuous'] = allow_promiscuous

        if beacon_interval and not isinstance(beacon_interval, int):
            raise TypeError('Expected property beacon_interval to be a int')
        __self__.beacon_interval = beacon_interval
        """
        The interval, in seconds, that a NIC beacon
        packet is sent out. This can be used with `check_beacon` to
        offer link failure capability beyond link status only. Default: `1`.
        """
        __props__['beaconInterval'] = beacon_interval

        if check_beacon and not isinstance(check_beacon, bool):
            raise TypeError('Expected property check_beacon to be a bool')
        __self__.check_beacon = check_beacon
        """
        Enable beacon probing - this requires that the
        `beacon_interval` option has been set in the bridge
        options. If this is set to `false`, only link status is used to check for
        failed NICs.  Default: `false`.
        """
        __props__['checkBeacon'] = check_beacon

        if failback and not isinstance(failback, bool):
            raise TypeError('Expected property failback to be a bool')
        __self__.failback = failback
        """
        If set to `true`, the teaming policy will re-activate
        failed interfaces higher in precedence when they come back up.  Default:
        `true`.
        """
        __props__['failback'] = failback

        if not host_system_id:
            raise TypeError('Missing required property host_system_id')
        elif not isinstance(host_system_id, basestring):
            raise TypeError('Expected property host_system_id to be a basestring')
        __self__.host_system_id = host_system_id
        """
        The [managed object ID][docs-about-morefs] of
        the host to set the virtual switch up on. Forces a new resource if changed.
        """
        __props__['hostSystemId'] = host_system_id

        if link_discovery_operation and not isinstance(link_discovery_operation, basestring):
            raise TypeError('Expected property link_discovery_operation to be a basestring')
        __self__.link_discovery_operation = link_discovery_operation
        """
        Whether to `advertise` or `listen`
        for link discovery traffic. Default: `listen`.
        """
        __props__['linkDiscoveryOperation'] = link_discovery_operation

        if link_discovery_protocol and not isinstance(link_discovery_protocol, basestring):
            raise TypeError('Expected property link_discovery_protocol to be a basestring')
        __self__.link_discovery_protocol = link_discovery_protocol
        """
        The discovery protocol type.  Valid
        types are `cpd` and `lldp`. Default: `cdp`.
        """
        __props__['linkDiscoveryProtocol'] = link_discovery_protocol

        if mtu and not isinstance(mtu, int):
            raise TypeError('Expected property mtu to be a int')
        __self__.mtu = mtu
        """
        The maximum transmission unit (MTU) for the virtual
        switch. Default: `1500`.
        """
        __props__['mtu'] = mtu

        if name and not isinstance(name, basestring):
            raise TypeError('Expected property name to be a basestring')
        __self__.name = name
        """
        The name of the virtual switch. Forces a new resource if
        changed.
        """
        __props__['name'] = name

        if not network_adapters:
            raise TypeError('Missing required property network_adapters')
        elif not isinstance(network_adapters, list):
            raise TypeError('Expected property network_adapters to be a list')
        __self__.network_adapters = network_adapters
        """
        The network interfaces to bind to the bridge.
        """
        __props__['networkAdapters'] = network_adapters

        if notify_switches and not isinstance(notify_switches, bool):
            raise TypeError('Expected property notify_switches to be a bool')
        __self__.notify_switches = notify_switches
        """
        If set to `true`, the teaming policy will
        notify the broadcast network of a NIC failover, triggering cache updates.
        Default: `true`.
        """
        __props__['notifySwitches'] = notify_switches

        if number_of_ports and not isinstance(number_of_ports, int):
            raise TypeError('Expected property number_of_ports to be a int')
        __self__.number_of_ports = number_of_ports
        """
        The number of ports to create with this
        virtual switch. Default: `128`.
        """
        __props__['numberOfPorts'] = number_of_ports

        if shaping_average_bandwidth and not isinstance(shaping_average_bandwidth, int):
            raise TypeError('Expected property shaping_average_bandwidth to be a int')
        __self__.shaping_average_bandwidth = shaping_average_bandwidth
        """
        The average bandwidth in bits per
        second if traffic shaping is enabled. Default: `0`
        """
        __props__['shapingAverageBandwidth'] = shaping_average_bandwidth

        if shaping_burst_size and not isinstance(shaping_burst_size, int):
            raise TypeError('Expected property shaping_burst_size to be a int')
        __self__.shaping_burst_size = shaping_burst_size
        """
        The maximum burst size allowed in bytes if
        shaping is enabled. Default: `0`
        """
        __props__['shapingBurstSize'] = shaping_burst_size

        if shaping_enabled and not isinstance(shaping_enabled, bool):
            raise TypeError('Expected property shaping_enabled to be a bool')
        __self__.shaping_enabled = shaping_enabled
        """
        Set to `true` to enable the traffic shaper for
        ports managed by this virtual switch. Default: `false`.
        """
        __props__['shapingEnabled'] = shaping_enabled

        if shaping_peak_bandwidth and not isinstance(shaping_peak_bandwidth, int):
            raise TypeError('Expected property shaping_peak_bandwidth to be a int')
        __self__.shaping_peak_bandwidth = shaping_peak_bandwidth
        """
        The peak bandwidth during bursts in
        bits per second if traffic shaping is enabled. Default: `0`
        """
        __props__['shapingPeakBandwidth'] = shaping_peak_bandwidth

        if not standby_nics:
            raise TypeError('Missing required property standby_nics')
        elif not isinstance(standby_nics, list):
            raise TypeError('Expected property standby_nics to be a list')
        __self__.standby_nics = standby_nics
        """
        The list of standby network adapters used for
        failover.
        """
        __props__['standbyNics'] = standby_nics

        if teaming_policy and not isinstance(teaming_policy, basestring):
            raise TypeError('Expected property teaming_policy to be a basestring')
        __self__.teaming_policy = teaming_policy
        """
        The network adapter teaming policy. Can be one
        of `loadbalance_ip`, `loadbalance_srcmac`, `loadbalance_srcid`, or
        `failover_explicit`. Default: `loadbalance_srcid`.
        """
        __props__['teamingPolicy'] = teaming_policy

        super(HostVirtualSwitch, __self__).__init__(
            'vsphere:index/hostVirtualSwitch:HostVirtualSwitch',
            __name__,
            __props__,
            __opts__)

    def set_outputs(self, outs):
        if 'activeNics' in outs:
            self.active_nics = outs['activeNics']
        if 'allowForgedTransmits' in outs:
            self.allow_forged_transmits = outs['allowForgedTransmits']
        if 'allowMacChanges' in outs:
            self.allow_mac_changes = outs['allowMacChanges']
        if 'allowPromiscuous' in outs:
            self.allow_promiscuous = outs['allowPromiscuous']
        if 'beaconInterval' in outs:
            self.beacon_interval = outs['beaconInterval']
        if 'checkBeacon' in outs:
            self.check_beacon = outs['checkBeacon']
        if 'failback' in outs:
            self.failback = outs['failback']
        if 'hostSystemId' in outs:
            self.host_system_id = outs['hostSystemId']
        if 'linkDiscoveryOperation' in outs:
            self.link_discovery_operation = outs['linkDiscoveryOperation']
        if 'linkDiscoveryProtocol' in outs:
            self.link_discovery_protocol = outs['linkDiscoveryProtocol']
        if 'mtu' in outs:
            self.mtu = outs['mtu']
        if 'name' in outs:
            self.name = outs['name']
        if 'networkAdapters' in outs:
            self.network_adapters = outs['networkAdapters']
        if 'notifySwitches' in outs:
            self.notify_switches = outs['notifySwitches']
        if 'numberOfPorts' in outs:
            self.number_of_ports = outs['numberOfPorts']
        if 'shapingAverageBandwidth' in outs:
            self.shaping_average_bandwidth = outs['shapingAverageBandwidth']
        if 'shapingBurstSize' in outs:
            self.shaping_burst_size = outs['shapingBurstSize']
        if 'shapingEnabled' in outs:
            self.shaping_enabled = outs['shapingEnabled']
        if 'shapingPeakBandwidth' in outs:
            self.shaping_peak_bandwidth = outs['shapingPeakBandwidth']
        if 'standbyNics' in outs:
            self.standby_nics = outs['standbyNics']
        if 'teamingPolicy' in outs:
            self.teaming_policy = outs['teamingPolicy']
