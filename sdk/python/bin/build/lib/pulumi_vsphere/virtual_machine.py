# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import pulumi
import pulumi.runtime

class VirtualMachine(pulumi.CustomResource):
    """
    The `vsphere_virtual_machine` resource can be used to manage the complex
    lifecycle of a virtual machine. It supports management of disk, network
    interface, and CDROM devices, creation from scratch or cloning from template,
    and migration through both host and storage vMotion.
    
    For more details on working with virtual machines in vSphere, see [this
    page][vmware-docs-vm-management].
    
    [vmware-docs-vm-management]: https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.vm_admin.doc/GUID-55238059-912E-411F-A0E9-A7A536972A91.html
    """
    def __init__(__self__, __name__, __opts__=None, alternate_guest_name=None, annotation=None, boot_delay=None, boot_retry_delay=None, boot_retry_enabled=None, cdrom=None, clone=None, cpu_hot_add_enabled=None, cpu_hot_remove_enabled=None, cpu_limit=None, cpu_performance_counters_enabled=None, cpu_reservation=None, cpu_share_count=None, cpu_share_level=None, custom_attributes=None, datastore_cluster_id=None, datastore_id=None, disks=None, efi_secure_boot_enabled=None, enable_disk_uuid=None, enable_logging=None, ept_rvi_mode=None, extra_config=None, firmware=None, folder=None, force_power_off=None, guest_id=None, host_system_id=None, hv_mode=None, latency_sensitivity=None, memory=None, memory_hot_add_enabled=None, memory_limit=None, memory_reservation=None, memory_share_count=None, memory_share_level=None, migrate_wait_timeout=None, name=None, nested_hv_enabled=None, network_interfaces=None, num_cores_per_socket=None, num_cpus=None, resource_pool_id=None, run_tools_scripts_after_power_on=None, run_tools_scripts_after_resume=None, run_tools_scripts_before_guest_reboot=None, run_tools_scripts_before_guest_shutdown=None, run_tools_scripts_before_guest_standby=None, scsi_bus_sharing=None, scsi_controller_count=None, scsi_type=None, shutdown_wait_timeout=None, swap_placement_policy=None, sync_time_with_host=None, tags=None, vapp=None, wait_for_guest_net_routable=None, wait_for_guest_net_timeout=None):
        """Create a VirtualMachine resource with the given unique name, props, and options."""
        if not __name__:
            raise TypeError('Missing resource name argument (for URN creation)')
        if not isinstance(__name__, basestring):
            raise TypeError('Expected resource name to be a string')
        if __opts__ and not isinstance(__opts__, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')

        __props__ = dict()

        if alternate_guest_name and not isinstance(alternate_guest_name, basestring):
            raise TypeError('Expected property alternate_guest_name to be a basestring')
        __self__.alternate_guest_name = alternate_guest_name
        """
        The guest name for the operating system
        when `guest_id` is `other` or `other-64`.
        """
        __props__['alternateGuestName'] = alternate_guest_name

        if annotation and not isinstance(annotation, basestring):
            raise TypeError('Expected property annotation to be a basestring')
        __self__.annotation = annotation
        """
        A user-provided description of the virtual machine.
        The default is no annotation.
        """
        __props__['annotation'] = annotation

        if boot_delay and not isinstance(boot_delay, int):
            raise TypeError('Expected property boot_delay to be a int')
        __self__.boot_delay = boot_delay
        """
        The number of milliseconds to wait before starting
        the boot sequence. The default is no delay.
        """
        __props__['bootDelay'] = boot_delay

        if boot_retry_delay and not isinstance(boot_retry_delay, int):
            raise TypeError('Expected property boot_retry_delay to be a int')
        __self__.boot_retry_delay = boot_retry_delay
        """
        The number of milliseconds to wait before
        retrying the boot sequence. This only valid if `boot_retry_enabled` is true.
        Default: `10000` (10 seconds).
        """
        __props__['bootRetryDelay'] = boot_retry_delay

        if boot_retry_enabled and not isinstance(boot_retry_enabled, bool):
            raise TypeError('Expected property boot_retry_enabled to be a bool')
        __self__.boot_retry_enabled = boot_retry_enabled
        """
        If set to true, a virtual machine that
        fails to boot will try again after the delay defined in `boot_retry_delay`.
        Default: `false`.
        """
        __props__['bootRetryEnabled'] = boot_retry_enabled

        if cdrom and not isinstance(cdrom, dict):
            raise TypeError('Expected property cdrom to be a dict')
        __self__.cdrom = cdrom
        """
        A specification for a CDROM device on this virtual
        machine. See CDROM options below.
        """
        __props__['cdrom'] = cdrom

        if clone and not isinstance(clone, dict):
            raise TypeError('Expected property clone to be a dict')
        __self__.clone = clone
        """
        When specified, the VM will be created as a clone of a
        specified template. Optional customization options can be submitted as well.
        See creating a virtual machine from a
        template for more details.
        """
        __props__['clone'] = clone

        if cpu_hot_add_enabled and not isinstance(cpu_hot_add_enabled, bool):
            raise TypeError('Expected property cpu_hot_add_enabled to be a bool')
        __self__.cpu_hot_add_enabled = cpu_hot_add_enabled
        """
        Allow CPUs to be added to this virtual
        machine while it is running.
        """
        __props__['cpuHotAddEnabled'] = cpu_hot_add_enabled

        if cpu_hot_remove_enabled and not isinstance(cpu_hot_remove_enabled, bool):
            raise TypeError('Expected property cpu_hot_remove_enabled to be a bool')
        __self__.cpu_hot_remove_enabled = cpu_hot_remove_enabled
        """
        Allow CPUs to be removed to this
        virtual machine while it is running.
        """
        __props__['cpuHotRemoveEnabled'] = cpu_hot_remove_enabled

        if cpu_limit and not isinstance(cpu_limit, int):
            raise TypeError('Expected property cpu_limit to be a int')
        __self__.cpu_limit = cpu_limit
        """
        The maximum amount of CPU (in MHz) that this virtual
        machine can consume, regardless of available resources. The default is no
        limit.
        """
        __props__['cpuLimit'] = cpu_limit

        if cpu_performance_counters_enabled and not isinstance(cpu_performance_counters_enabled, bool):
            raise TypeError('Expected property cpu_performance_counters_enabled to be a bool')
        __self__.cpu_performance_counters_enabled = cpu_performance_counters_enabled
        """
        Enable CPU performance
        counters on this virtual machine. Default: `false`.
        """
        __props__['cpuPerformanceCountersEnabled'] = cpu_performance_counters_enabled

        if cpu_reservation and not isinstance(cpu_reservation, int):
            raise TypeError('Expected property cpu_reservation to be a int')
        __self__.cpu_reservation = cpu_reservation
        """
        The amount of CPU (in MHz) that this virtual
        machine is guaranteed. The default is no reservation.
        """
        __props__['cpuReservation'] = cpu_reservation

        if cpu_share_count and not isinstance(cpu_share_count, int):
            raise TypeError('Expected property cpu_share_count to be a int')
        __self__.cpu_share_count = cpu_share_count
        """
        The number of CPU shares allocated to the
        virtual machine when the `cpu_share_level` is `custom`.
        """
        __props__['cpuShareCount'] = cpu_share_count

        if cpu_share_level and not isinstance(cpu_share_level, basestring):
            raise TypeError('Expected property cpu_share_level to be a basestring')
        __self__.cpu_share_level = cpu_share_level
        """
        The allocation level for CPU resources. Can be
        one of `high`, `low`, `normal`, or `custom`. Default: `custom`.
        """
        __props__['cpuShareLevel'] = cpu_share_level

        if custom_attributes and not isinstance(custom_attributes, dict):
            raise TypeError('Expected property custom_attributes to be a dict')
        __self__.custom_attributes = custom_attributes
        """
        Map of custom attribute ids to attribute
        value strings to set for virtual machine. See
        [here][docs-setting-custom-attributes] for a reference on how to set values
        for custom attributes.
        """
        __props__['customAttributes'] = custom_attributes

        if datastore_cluster_id and not isinstance(datastore_cluster_id, basestring):
            raise TypeError('Expected property datastore_cluster_id to be a basestring')
        __self__.datastore_cluster_id = datastore_cluster_id
        """
        The [managed object reference
        ID][docs-about-morefs] of the datastore cluster ID to use. This setting
        applies to entire virtual machine and implies that you wish to use Storage
        DRS with this virtual machine. See the section on virtual machine
        migration for details on changing this value.
        """
        __props__['datastoreClusterId'] = datastore_cluster_id

        if datastore_id and not isinstance(datastore_id, basestring):
            raise TypeError('Expected property datastore_id to be a basestring')
        __self__.datastore_id = datastore_id
        """
        The datastore ID that the ISO is located in.
        Requried for using a datastore ISO. Conflicts with `client_device`.
        """
        __props__['datastoreId'] = datastore_id

        if disks and not isinstance(disks, list):
            raise TypeError('Expected property disks to be a list')
        __self__.disks = disks
        """
        A specification for a virtual disk device on this virtual
        machine. See disk options below.
        """
        __props__['disks'] = disks

        if efi_secure_boot_enabled and not isinstance(efi_secure_boot_enabled, bool):
            raise TypeError('Expected property efi_secure_boot_enabled to be a bool')
        __self__.efi_secure_boot_enabled = efi_secure_boot_enabled
        """
        When the `firmware` type is set to is
        `efi`, this enables EFI secure boot. Default: `false`.
        """
        __props__['efiSecureBootEnabled'] = efi_secure_boot_enabled

        if enable_disk_uuid and not isinstance(enable_disk_uuid, bool):
            raise TypeError('Expected property enable_disk_uuid to be a bool')
        __self__.enable_disk_uuid = enable_disk_uuid
        """
        Expose the UUIDs of attached virtual disks to
        the virtual machine, allowing access to them in the guest. Default: `false`.
        """
        __props__['enableDiskUuid'] = enable_disk_uuid

        if enable_logging and not isinstance(enable_logging, bool):
            raise TypeError('Expected property enable_logging to be a bool')
        __self__.enable_logging = enable_logging
        """
        Enable logging of virtual machine events to a
        log file stored in the virtual machine directory. Default: `false`.
        """
        __props__['enableLogging'] = enable_logging

        if ept_rvi_mode and not isinstance(ept_rvi_mode, basestring):
            raise TypeError('Expected property ept_rvi_mode to be a basestring')
        __self__.ept_rvi_mode = ept_rvi_mode
        """
        The EPT/RVI (hardware memory virtualization)
        setting for this virtual machine. Can be one of `automatic`, `on`, or `off`.
        Default: `automatic`.
        """
        __props__['eptRviMode'] = ept_rvi_mode

        if extra_config and not isinstance(extra_config, dict):
            raise TypeError('Expected property extra_config to be a dict')
        __self__.extra_config = extra_config
        """
        Extra configuration data for this virtual
        machine. Can be used to supply advanced parameters not normally in
        configuration, such as data for cloud-config (under the guestinfo namespace).
        """
        __props__['extraConfig'] = extra_config

        if firmware and not isinstance(firmware, basestring):
            raise TypeError('Expected property firmware to be a basestring')
        __self__.firmware = firmware
        """
        The firmware interface to use on the virtual machine.
        Can be one of `bios` or `EFI`. Default: `bios`.
        """
        __props__['firmware'] = firmware

        if folder and not isinstance(folder, basestring):
            raise TypeError('Expected property folder to be a basestring')
        __self__.folder = folder
        """
        The path to the folder to put this virtual machine in,
        relative to the datacenter that the resource pool is in.
        """
        __props__['folder'] = folder

        if force_power_off and not isinstance(force_power_off, bool):
            raise TypeError('Expected property force_power_off to be a bool')
        __self__.force_power_off = force_power_off
        """
        If a guest shutdown failed or timed out while
        updating or destroying (see
        `shutdown_wait_timeout`), force the power-off of
        the virtual machine. Default: `true`.
        """
        __props__['forcePowerOff'] = force_power_off

        if guest_id and not isinstance(guest_id, basestring):
            raise TypeError('Expected property guest_id to be a basestring')
        __self__.guest_id = guest_id
        """
        The guest ID for the operating system type. For a
        full list of possible values, see [here][vmware-docs-guest-ids]. Default: `other-64`.
        """
        __props__['guestId'] = guest_id

        if host_system_id and not isinstance(host_system_id, basestring):
            raise TypeError('Expected property host_system_id to be a basestring')
        __self__.host_system_id = host_system_id
        """
        An optional [managed object reference
        ID][docs-about-morefs] of a host to put this virtual machine on. See the
        section on virtual machine migration for
        details on changing this value. If a `host_system_id` is not supplied,
        vSphere will select a host in the resource pool to place the virtual machine,
        according to any defaults or DRS policies in place.
        """
        __props__['hostSystemId'] = host_system_id

        if hv_mode and not isinstance(hv_mode, basestring):
            raise TypeError('Expected property hv_mode to be a basestring')
        __self__.hv_mode = hv_mode
        """
        The (non-nested) hardware virtualization setting for
        this virtual machine. Can be one of `hvAuto`, `hvOn`, or `hvOff`. Default:
        `hvAuto`.
        """
        __props__['hvMode'] = hv_mode

        if latency_sensitivity and not isinstance(latency_sensitivity, basestring):
            raise TypeError('Expected property latency_sensitivity to be a basestring')
        __self__.latency_sensitivity = latency_sensitivity
        """
        Controls the scheduling delay of the
        virtual machine. Use a higher sensitivity for applications that require lower
        latency, such as VOIP, media player applications, or applications that
        require frequent access to mouse or keyboard devices. Can be one of `low`,
        `normal`, `medium`, or `high`.
        """
        __props__['latencySensitivity'] = latency_sensitivity

        if memory and not isinstance(memory, int):
            raise TypeError('Expected property memory to be a int')
        __self__.memory = memory
        """
        The size of the virtual machine's memory, in MB.
        Default: `1024` (1 GB).
        """
        __props__['memory'] = memory

        if memory_hot_add_enabled and not isinstance(memory_hot_add_enabled, bool):
            raise TypeError('Expected property memory_hot_add_enabled to be a bool')
        __self__.memory_hot_add_enabled = memory_hot_add_enabled
        """
        Allow memory to be added to this
        virtual machine while it is running.
        """
        __props__['memoryHotAddEnabled'] = memory_hot_add_enabled

        if memory_limit and not isinstance(memory_limit, int):
            raise TypeError('Expected property memory_limit to be a int')
        __self__.memory_limit = memory_limit
        """
        The maximum amount of memory (in MB) that this
        virtual machine can consume, regardless of available resources. The default
        is no limit.
        """
        __props__['memoryLimit'] = memory_limit

        if memory_reservation and not isinstance(memory_reservation, int):
            raise TypeError('Expected property memory_reservation to be a int')
        __self__.memory_reservation = memory_reservation
        """
        The amount of memory (in MB) that this
        virtual machine is guaranteed. The default is no reservation.
        """
        __props__['memoryReservation'] = memory_reservation

        if memory_share_count and not isinstance(memory_share_count, int):
            raise TypeError('Expected property memory_share_count to be a int')
        __self__.memory_share_count = memory_share_count
        """
        The number of memory shares allocated to
        the virtual machine when the `memory_share_level` is `custom`.
        """
        __props__['memoryShareCount'] = memory_share_count

        if memory_share_level and not isinstance(memory_share_level, basestring):
            raise TypeError('Expected property memory_share_level to be a basestring')
        __self__.memory_share_level = memory_share_level
        """
        The allocation level for memory resources.
        Can be one of `high`, `low`, `normal`, or `custom`. Default: `custom`.
        """
        __props__['memoryShareLevel'] = memory_share_level

        if migrate_wait_timeout and not isinstance(migrate_wait_timeout, int):
            raise TypeError('Expected property migrate_wait_timeout to be a int')
        __self__.migrate_wait_timeout = migrate_wait_timeout
        """
        The amount of time, in minutes, to wait
        for a virtual machine migration to complete before failing. Default: 10
        minutes. Also see the section on virtual machine
        migration.
        """
        __props__['migrateWaitTimeout'] = migrate_wait_timeout

        if name and not isinstance(name, basestring):
            raise TypeError('Expected property name to be a basestring')
        __self__.name = name
        """
        An alias for both `label` and `path`, the latter when
        using `attach`. Required if not using `label`.
        """
        __props__['name'] = name

        if nested_hv_enabled and not isinstance(nested_hv_enabled, bool):
            raise TypeError('Expected property nested_hv_enabled to be a bool')
        __self__.nested_hv_enabled = nested_hv_enabled
        """
        Enable nested hardware virtualization on
        this virtual machine, facilitating nested virtualization in the guest.
        Default: `false`.
        """
        __props__['nestedHvEnabled'] = nested_hv_enabled

        if not network_interfaces:
            raise TypeError('Missing required property network_interfaces')
        elif not isinstance(network_interfaces, list):
            raise TypeError('Expected property network_interfaces to be a list')
        __self__.network_interfaces = network_interfaces
        """
        A specification for a virtual NIC on this
        virtual machine. See network interface options
        below.
        """
        __props__['networkInterfaces'] = network_interfaces

        if num_cores_per_socket and not isinstance(num_cores_per_socket, int):
            raise TypeError('Expected property num_cores_per_socket to be a int')
        __self__.num_cores_per_socket = num_cores_per_socket
        """
        The number of cores to distribute among
        the CPUs in this virtual machine. If specified, the value supplied to
        `num_cpus` must be evenly divisible by this value. Default: `1`.
        """
        __props__['numCoresPerSocket'] = num_cores_per_socket

        if num_cpus and not isinstance(num_cpus, int):
            raise TypeError('Expected property num_cpus to be a int')
        __self__.num_cpus = num_cpus
        """
        The number of virtual processors to assign to this
        virtual machine. Default: `1`.
        """
        __props__['numCpus'] = num_cpus

        if not resource_pool_id:
            raise TypeError('Missing required property resource_pool_id')
        elif not isinstance(resource_pool_id, basestring):
            raise TypeError('Expected property resource_pool_id to be a basestring')
        __self__.resource_pool_id = resource_pool_id
        """
        The [managed object reference
        ID][docs-about-morefs] of the resource pool to put this virtual machine in.
        See the section on virtual machine migration
        for details on changing this value.
        """
        __props__['resourcePoolId'] = resource_pool_id

        if run_tools_scripts_after_power_on and not isinstance(run_tools_scripts_after_power_on, bool):
            raise TypeError('Expected property run_tools_scripts_after_power_on to be a bool')
        __self__.run_tools_scripts_after_power_on = run_tools_scripts_after_power_on
        """
        Enable the execution of
        post-power-on scripts when VMware tools is installed. Default: `true`.
        """
        __props__['runToolsScriptsAfterPowerOn'] = run_tools_scripts_after_power_on

        if run_tools_scripts_after_resume and not isinstance(run_tools_scripts_after_resume, bool):
            raise TypeError('Expected property run_tools_scripts_after_resume to be a bool')
        __self__.run_tools_scripts_after_resume = run_tools_scripts_after_resume
        """
        Enable the execution of
        post-resume scripts when VMware tools is installed. Default: `true`.
        """
        __props__['runToolsScriptsAfterResume'] = run_tools_scripts_after_resume

        if run_tools_scripts_before_guest_reboot and not isinstance(run_tools_scripts_before_guest_reboot, bool):
            raise TypeError('Expected property run_tools_scripts_before_guest_reboot to be a bool')
        __self__.run_tools_scripts_before_guest_reboot = run_tools_scripts_before_guest_reboot
        """
        Enable the execution of
        pre-reboot scripts when VMware tools is installed. Default: `false`.
        """
        __props__['runToolsScriptsBeforeGuestReboot'] = run_tools_scripts_before_guest_reboot

        if run_tools_scripts_before_guest_shutdown and not isinstance(run_tools_scripts_before_guest_shutdown, bool):
            raise TypeError('Expected property run_tools_scripts_before_guest_shutdown to be a bool')
        __self__.run_tools_scripts_before_guest_shutdown = run_tools_scripts_before_guest_shutdown
        """
        Enable the execution
        of pre-shutdown scripts when VMware tools is installed. Default: `true`.
        """
        __props__['runToolsScriptsBeforeGuestShutdown'] = run_tools_scripts_before_guest_shutdown

        if run_tools_scripts_before_guest_standby and not isinstance(run_tools_scripts_before_guest_standby, bool):
            raise TypeError('Expected property run_tools_scripts_before_guest_standby to be a bool')
        __self__.run_tools_scripts_before_guest_standby = run_tools_scripts_before_guest_standby
        """
        Enable the execution of
        pre-standby scripts when VMware tools is installed. Default: `true`.
        """
        __props__['runToolsScriptsBeforeGuestStandby'] = run_tools_scripts_before_guest_standby

        if scsi_bus_sharing and not isinstance(scsi_bus_sharing, basestring):
            raise TypeError('Expected property scsi_bus_sharing to be a basestring')
        __self__.scsi_bus_sharing = scsi_bus_sharing
        """
        Mode for sharing the SCSI bus. The modes are
        physicalSharing, virtualSharing, and noSharing. Default: `noSharing`.
        """
        __props__['scsiBusSharing'] = scsi_bus_sharing

        if scsi_controller_count and not isinstance(scsi_controller_count, int):
            raise TypeError('Expected property scsi_controller_count to be a int')
        __self__.scsi_controller_count = scsi_controller_count
        """
        The number of SCSI controllers that
        Terraform manages on this virtual machine. This directly affects the amount
        of disks you can add to the virtual machine and the maximum disk unit number.
        Note that lowering this value does not remove controllers. Default: `1`.
        """
        __props__['scsiControllerCount'] = scsi_controller_count

        if scsi_type and not isinstance(scsi_type, basestring):
            raise TypeError('Expected property scsi_type to be a basestring')
        __self__.scsi_type = scsi_type
        """
        The type of SCSI bus this virtual machine will have.
        Can be one of lsilogic (LSI Logic Parallel), lsilogic-sas (LSI Logic SAS) or
        pvscsi (VMware Paravirtual). Defualt: `pvscsi`.
        """
        __props__['scsiType'] = scsi_type

        if shutdown_wait_timeout and not isinstance(shutdown_wait_timeout, int):
            raise TypeError('Expected property shutdown_wait_timeout to be a int')
        __self__.shutdown_wait_timeout = shutdown_wait_timeout
        """
        The amount of time, in minutes, to wait
        for a graceful guest shutdown when making necessary updates to the virtual
        machine. If `force_power_off` is set to true, the VM will be force powered-off
        after this timeout, otherwise an error is returned. Default: 3 minutes.
        """
        __props__['shutdownWaitTimeout'] = shutdown_wait_timeout

        if swap_placement_policy and not isinstance(swap_placement_policy, basestring):
            raise TypeError('Expected property swap_placement_policy to be a basestring')
        __self__.swap_placement_policy = swap_placement_policy
        """
        The swap file placement policy for this
        virtual machine. Can be one of `inherit`, `hostLocal`, or `vmDirectory`.
        Default: `inherit`.
        """
        __props__['swapPlacementPolicy'] = swap_placement_policy

        if sync_time_with_host and not isinstance(sync_time_with_host, bool):
            raise TypeError('Expected property sync_time_with_host to be a bool')
        __self__.sync_time_with_host = sync_time_with_host
        """
        Enable guest clock synchronization with
        the host. Requires VMware tools to be installed. Default: `false`.
        """
        __props__['syncTimeWithHost'] = sync_time_with_host

        if tags and not isinstance(tags, list):
            raise TypeError('Expected property tags to be a list')
        __self__.tags = tags
        """
        The IDs of any tags to attach to this resource. See
        [here][docs-applying-tags] for a reference on how to apply tags.
        """
        __props__['tags'] = tags

        if vapp and not isinstance(vapp, dict):
            raise TypeError('Expected property vapp to be a dict')
        __self__.vapp = vapp
        """
        Optional vApp configuration. The only sub-key available
        is `properties`, which is a key/value map of properties for virtual machines
        imported from OVF or OVA files. See Using vApp properties to supply OVF/OVA
        configuration for
        more details.
        """
        __props__['vapp'] = vapp

        if wait_for_guest_net_routable and not isinstance(wait_for_guest_net_routable, bool):
            raise TypeError('Expected property wait_for_guest_net_routable to be a bool')
        __self__.wait_for_guest_net_routable = wait_for_guest_net_routable
        """
        Controls whether or not the guest
        network waiter waits for a routable address. When `false`, the waiter does
        not wait for a default gateway, nor are IP addresses checked against any
        discovered default gateways as part of its success criteria. Default: `true`.
        """
        __props__['waitForGuestNetRoutable'] = wait_for_guest_net_routable

        if wait_for_guest_net_timeout and not isinstance(wait_for_guest_net_timeout, int):
            raise TypeError('Expected property wait_for_guest_net_timeout to be a int')
        __self__.wait_for_guest_net_timeout = wait_for_guest_net_timeout
        """
        The amount of time, in minutes, to
        wait for an available IP address on this virtual machine. A value less than 1
        disables the waiter. Default: 5 minutes.
        """
        __props__['waitForGuestNetTimeout'] = wait_for_guest_net_timeout

        __self__.change_version = pulumi.runtime.UNKNOWN
        """
        A unique identifier for a given version of the last
        configuration applied, such the timestamp of the last update to the
        configuration.
        """
        __self__.default_ip_address = pulumi.runtime.UNKNOWN
        """
        The IP address selected by Terraform to be used with
        any [provisioners][tf-docs-provisioners] configured on this resource.
        Whenever possible, this is the first IPv4 address that is reachable through
        the default gateway configured on the machine, then the first reachable IPv6
        address, and then the first general discovered address if neither exist. If
        VMware tools is not running on the virtual machine, or if the VM is powered
        off, this value will be blank.
        """
        __self__.guest_ip_addresses = pulumi.runtime.UNKNOWN
        """
        The current list of IP addresses on this machine,
        including the value of `default_ip_address`. If VMware tools is not running
        on the virtual machine, or if the VM is powered off, this list will be empty.
        * `moid`: The [managed object reference ID][docs-about-morefs] of the created
        virtual machine.
        """
        __self__.imported = pulumi.runtime.UNKNOWN
        """
        This is flagged if the virtual machine has been imported, or the
        state has been migrated from a previous version of the resource. It
        influences the behavior of the first post-import apply operation. See the
        section on importing below.
        """
        __self__.moid = pulumi.runtime.UNKNOWN
        """
        The machine object ID from VMWare
        """
        __self__.reboot_required = pulumi.runtime.UNKNOWN
        """
        Value internal to Terraform used to determine if a
        configuration set change requires a reboot. This value is only useful during
        an update process and gets reset on refresh.
        """
        __self__.uuid = pulumi.runtime.UNKNOWN
        """
        The UUID of the virtual disk's VMDK file. This is used to track the
        virtual disk on the virtual machine.
        """
        __self__.vapp_transports = pulumi.runtime.UNKNOWN
        """
        Computed value which is only valid for cloned virtual
        machines. A list of vApp transport methods supported by the source virtual
        machine or template.
        """
        __self__.vmware_tools_status = pulumi.runtime.UNKNOWN
        """
        The state of VMware tools in the guest. This will
        determine the proper course of action for some device operations.
        """
        __self__.vmx_path = pulumi.runtime.UNKNOWN
        """
        The path of the virtual machine's configuration file in the VM's
        datastore.
        """

        super(VirtualMachine, __self__).__init__(
            'vsphere:index/virtualMachine:VirtualMachine',
            __name__,
            __props__,
            __opts__)

    def set_outputs(self, outs):
        if 'alternateGuestName' in outs:
            self.alternate_guest_name = outs['alternateGuestName']
        if 'annotation' in outs:
            self.annotation = outs['annotation']
        if 'bootDelay' in outs:
            self.boot_delay = outs['bootDelay']
        if 'bootRetryDelay' in outs:
            self.boot_retry_delay = outs['bootRetryDelay']
        if 'bootRetryEnabled' in outs:
            self.boot_retry_enabled = outs['bootRetryEnabled']
        if 'cdrom' in outs:
            self.cdrom = outs['cdrom']
        if 'changeVersion' in outs:
            self.change_version = outs['changeVersion']
        if 'clone' in outs:
            self.clone = outs['clone']
        if 'cpuHotAddEnabled' in outs:
            self.cpu_hot_add_enabled = outs['cpuHotAddEnabled']
        if 'cpuHotRemoveEnabled' in outs:
            self.cpu_hot_remove_enabled = outs['cpuHotRemoveEnabled']
        if 'cpuLimit' in outs:
            self.cpu_limit = outs['cpuLimit']
        if 'cpuPerformanceCountersEnabled' in outs:
            self.cpu_performance_counters_enabled = outs['cpuPerformanceCountersEnabled']
        if 'cpuReservation' in outs:
            self.cpu_reservation = outs['cpuReservation']
        if 'cpuShareCount' in outs:
            self.cpu_share_count = outs['cpuShareCount']
        if 'cpuShareLevel' in outs:
            self.cpu_share_level = outs['cpuShareLevel']
        if 'customAttributes' in outs:
            self.custom_attributes = outs['customAttributes']
        if 'datastoreClusterId' in outs:
            self.datastore_cluster_id = outs['datastoreClusterId']
        if 'datastoreId' in outs:
            self.datastore_id = outs['datastoreId']
        if 'defaultIpAddress' in outs:
            self.default_ip_address = outs['defaultIpAddress']
        if 'disks' in outs:
            self.disks = outs['disks']
        if 'efiSecureBootEnabled' in outs:
            self.efi_secure_boot_enabled = outs['efiSecureBootEnabled']
        if 'enableDiskUuid' in outs:
            self.enable_disk_uuid = outs['enableDiskUuid']
        if 'enableLogging' in outs:
            self.enable_logging = outs['enableLogging']
        if 'eptRviMode' in outs:
            self.ept_rvi_mode = outs['eptRviMode']
        if 'extraConfig' in outs:
            self.extra_config = outs['extraConfig']
        if 'firmware' in outs:
            self.firmware = outs['firmware']
        if 'folder' in outs:
            self.folder = outs['folder']
        if 'forcePowerOff' in outs:
            self.force_power_off = outs['forcePowerOff']
        if 'guestId' in outs:
            self.guest_id = outs['guestId']
        if 'guestIpAddresses' in outs:
            self.guest_ip_addresses = outs['guestIpAddresses']
        if 'hostSystemId' in outs:
            self.host_system_id = outs['hostSystemId']
        if 'hvMode' in outs:
            self.hv_mode = outs['hvMode']
        if 'imported' in outs:
            self.imported = outs['imported']
        if 'latencySensitivity' in outs:
            self.latency_sensitivity = outs['latencySensitivity']
        if 'memory' in outs:
            self.memory = outs['memory']
        if 'memoryHotAddEnabled' in outs:
            self.memory_hot_add_enabled = outs['memoryHotAddEnabled']
        if 'memoryLimit' in outs:
            self.memory_limit = outs['memoryLimit']
        if 'memoryReservation' in outs:
            self.memory_reservation = outs['memoryReservation']
        if 'memoryShareCount' in outs:
            self.memory_share_count = outs['memoryShareCount']
        if 'memoryShareLevel' in outs:
            self.memory_share_level = outs['memoryShareLevel']
        if 'migrateWaitTimeout' in outs:
            self.migrate_wait_timeout = outs['migrateWaitTimeout']
        if 'moid' in outs:
            self.moid = outs['moid']
        if 'name' in outs:
            self.name = outs['name']
        if 'nestedHvEnabled' in outs:
            self.nested_hv_enabled = outs['nestedHvEnabled']
        if 'networkInterfaces' in outs:
            self.network_interfaces = outs['networkInterfaces']
        if 'numCoresPerSocket' in outs:
            self.num_cores_per_socket = outs['numCoresPerSocket']
        if 'numCpus' in outs:
            self.num_cpus = outs['numCpus']
        if 'rebootRequired' in outs:
            self.reboot_required = outs['rebootRequired']
        if 'resourcePoolId' in outs:
            self.resource_pool_id = outs['resourcePoolId']
        if 'runToolsScriptsAfterPowerOn' in outs:
            self.run_tools_scripts_after_power_on = outs['runToolsScriptsAfterPowerOn']
        if 'runToolsScriptsAfterResume' in outs:
            self.run_tools_scripts_after_resume = outs['runToolsScriptsAfterResume']
        if 'runToolsScriptsBeforeGuestReboot' in outs:
            self.run_tools_scripts_before_guest_reboot = outs['runToolsScriptsBeforeGuestReboot']
        if 'runToolsScriptsBeforeGuestShutdown' in outs:
            self.run_tools_scripts_before_guest_shutdown = outs['runToolsScriptsBeforeGuestShutdown']
        if 'runToolsScriptsBeforeGuestStandby' in outs:
            self.run_tools_scripts_before_guest_standby = outs['runToolsScriptsBeforeGuestStandby']
        if 'scsiBusSharing' in outs:
            self.scsi_bus_sharing = outs['scsiBusSharing']
        if 'scsiControllerCount' in outs:
            self.scsi_controller_count = outs['scsiControllerCount']
        if 'scsiType' in outs:
            self.scsi_type = outs['scsiType']
        if 'shutdownWaitTimeout' in outs:
            self.shutdown_wait_timeout = outs['shutdownWaitTimeout']
        if 'swapPlacementPolicy' in outs:
            self.swap_placement_policy = outs['swapPlacementPolicy']
        if 'syncTimeWithHost' in outs:
            self.sync_time_with_host = outs['syncTimeWithHost']
        if 'tags' in outs:
            self.tags = outs['tags']
        if 'uuid' in outs:
            self.uuid = outs['uuid']
        if 'vapp' in outs:
            self.vapp = outs['vapp']
        if 'vappTransports' in outs:
            self.vapp_transports = outs['vappTransports']
        if 'vmwareToolsStatus' in outs:
            self.vmware_tools_status = outs['vmwareToolsStatus']
        if 'vmxPath' in outs:
            self.vmx_path = outs['vmxPath']
        if 'waitForGuestNetRoutable' in outs:
            self.wait_for_guest_net_routable = outs['waitForGuestNetRoutable']
        if 'waitForGuestNetTimeout' in outs:
            self.wait_for_guest_net_timeout = outs['waitForGuestNetTimeout']
