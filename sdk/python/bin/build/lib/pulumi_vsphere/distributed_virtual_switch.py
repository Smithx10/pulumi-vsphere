# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import pulumi
import pulumi.runtime

class DistributedVirtualSwitch(pulumi.CustomResource):
    """
    The `vsphere_distributed_virtual_switch` resource can be used to manage VMware
    Distributed Virtual Switches.
    
    An essential component of a distributed, scalable VMware datacenter, the
    vSphere Distributed Virtual Switch (DVS) provides centralized management and
    monitoring of the networking configuration of all the hosts that are associated
    with the switch. In addition to adding port groups (see the
    [`vsphere_distributed_port_group`][distributed-port-group] resource) that can
    be used as networks for virtual machines, a DVS can be configured to perform
    advanced high availability, traffic shaping, network monitoring, and more.
    
    For an overview on vSphere networking concepts, see [this
    page][ref-vsphere-net-concepts]. For more information on vSphere DVS, see [this
    page][ref-vsphere-dvs].
    
    [distributed-port-group]: /docs/providers/vsphere/r/distributed_port_group.html
    [ref-vsphere-net-concepts]: https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.networking.doc/GUID-2B11DBB8-CB3C-4AFF-8885-EFEA0FC562F4.html
    [ref-vsphere-dvs]: https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.networking.doc/GUID-375B45C7-684C-4C51-BA3C-70E48DFABF04.html
    
    ~> **NOTE:** This resource requires vCenter and is not available on direct ESXi
    connections.
    """
    def __init__(__self__, __name__, __opts__=None, active_uplinks=None, allow_forged_transmits=None, allow_mac_changes=None, allow_promiscuous=None, block_all_ports=None, check_beacon=None, contact_detail=None, contact_name=None, custom_attributes=None, datacenter_id=None, description=None, directpath_gen2_allowed=None, egress_shaping_average_bandwidth=None, egress_shaping_burst_size=None, egress_shaping_enabled=None, egress_shaping_peak_bandwidth=None, failback=None, faulttolerance_maximum_mbit=None, faulttolerance_reservation_mbit=None, faulttolerance_share_count=None, faulttolerance_share_level=None, folder=None, hbr_maximum_mbit=None, hbr_reservation_mbit=None, hbr_share_count=None, hbr_share_level=None, hosts=None, ingress_shaping_average_bandwidth=None, ingress_shaping_burst_size=None, ingress_shaping_enabled=None, ingress_shaping_peak_bandwidth=None, ipv4_address=None, iscsi_maximum_mbit=None, iscsi_reservation_mbit=None, iscsi_share_count=None, iscsi_share_level=None, lacp_api_version=None, lacp_enabled=None, lacp_mode=None, link_discovery_operation=None, link_discovery_protocol=None, management_maximum_mbit=None, management_reservation_mbit=None, management_share_count=None, management_share_level=None, max_mtu=None, multicast_filtering_mode=None, name=None, netflow_active_flow_timeout=None, netflow_collector_ip_address=None, netflow_collector_port=None, netflow_enabled=None, netflow_idle_flow_timeout=None, netflow_internal_flows_only=None, netflow_observation_domain_id=None, netflow_sampling_rate=None, network_resource_control_enabled=None, network_resource_control_version=None, nfs_maximum_mbit=None, nfs_reservation_mbit=None, nfs_share_count=None, nfs_share_level=None, notify_switches=None, port_private_secondary_vlan_id=None, standby_uplinks=None, tags=None, teaming_policy=None, tx_uplink=None, uplinks=None, vdp_maximum_mbit=None, vdp_reservation_mbit=None, vdp_share_count=None, vdp_share_level=None, version=None, virtualmachine_maximum_mbit=None, virtualmachine_reservation_mbit=None, virtualmachine_share_count=None, virtualmachine_share_level=None, vlan_id=None, vlan_ranges=None, vmotion_maximum_mbit=None, vmotion_reservation_mbit=None, vmotion_share_count=None, vmotion_share_level=None, vsan_maximum_mbit=None, vsan_reservation_mbit=None, vsan_share_count=None, vsan_share_level=None):
        """Create a DistributedVirtualSwitch resource with the given unique name, props, and options."""
        if not __name__:
            raise TypeError('Missing resource name argument (for URN creation)')
        if not isinstance(__name__, basestring):
            raise TypeError('Expected resource name to be a string')
        if __opts__ and not isinstance(__opts__, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')

        __props__ = dict()

        if active_uplinks and not isinstance(active_uplinks, list):
            raise TypeError('Expected property active_uplinks to be a list')
        __self__.active_uplinks = active_uplinks
        """
        A list of active uplinks to be used in load
        balancing. These uplinks need to match the definitions in the
        `uplinks` DVS argument. See
        here for more details.
        """
        __props__['activeUplinks'] = active_uplinks

        if allow_forged_transmits and not isinstance(allow_forged_transmits, bool):
            raise TypeError('Expected property allow_forged_transmits to be a bool')
        __self__.allow_forged_transmits = allow_forged_transmits
        """
        Controls whether or not a virtual
        network adapter is allowed to send network traffic with a different MAC
        address than that of its own.
        """
        __props__['allowForgedTransmits'] = allow_forged_transmits

        if allow_mac_changes and not isinstance(allow_mac_changes, bool):
            raise TypeError('Expected property allow_mac_changes to be a bool')
        __self__.allow_mac_changes = allow_mac_changes
        """
        Controls whether or not the Media Access
        Control (MAC) address can be changed.
        """
        __props__['allowMacChanges'] = allow_mac_changes

        if allow_promiscuous and not isinstance(allow_promiscuous, bool):
            raise TypeError('Expected property allow_promiscuous to be a bool')
        __self__.allow_promiscuous = allow_promiscuous
        """
        Enable promiscuous mode on the network. This
        flag indicates whether or not all traffic is seen on a given port.
        """
        __props__['allowPromiscuous'] = allow_promiscuous

        if block_all_ports and not isinstance(block_all_ports, bool):
            raise TypeError('Expected property block_all_ports to be a bool')
        __self__.block_all_ports = block_all_ports
        """
        Shuts down all ports in the port groups that
        this policy applies to, effectively blocking all network access to connected
        virtual devices.
        """
        __props__['blockAllPorts'] = block_all_ports

        if check_beacon and not isinstance(check_beacon, bool):
            raise TypeError('Expected property check_beacon to be a bool')
        __self__.check_beacon = check_beacon
        """
        Enables beacon probing as an additional measure
        to detect NIC failure.
        """
        __props__['checkBeacon'] = check_beacon

        if contact_detail and not isinstance(contact_detail, basestring):
            raise TypeError('Expected property contact_detail to be a basestring')
        __self__.contact_detail = contact_detail
        """
        The detailed contact information for the person
        who is responsible for the DVS.
        """
        __props__['contactDetail'] = contact_detail

        if contact_name and not isinstance(contact_name, basestring):
            raise TypeError('Expected property contact_name to be a basestring')
        __self__.contact_name = contact_name
        """
        The name of the person who is responsible for the
        DVS.
        """
        __props__['contactName'] = contact_name

        if custom_attributes and not isinstance(custom_attributes, dict):
            raise TypeError('Expected property custom_attributes to be a dict')
        __self__.custom_attributes = custom_attributes
        """
        Map of custom attribute ids to attribute
        value strings to set for virtual switch. See
        [here][docs-setting-custom-attributes] for a reference on how to set values
        for custom attributes.
        """
        __props__['customAttributes'] = custom_attributes

        if not datacenter_id:
            raise TypeError('Missing required property datacenter_id')
        elif not isinstance(datacenter_id, basestring):
            raise TypeError('Expected property datacenter_id to be a basestring')
        __self__.datacenter_id = datacenter_id
        """
        The ID of the datacenter where the distributed
        virtual switch will be created. Forces a new resource if changed.
        """
        __props__['datacenterId'] = datacenter_id

        if description and not isinstance(description, basestring):
            raise TypeError('Expected property description to be a basestring')
        __self__.description = description
        """
        A detailed description for the DVS.
        """
        __props__['description'] = description

        if directpath_gen2_allowed and not isinstance(directpath_gen2_allowed, bool):
            raise TypeError('Expected property directpath_gen2_allowed to be a bool')
        __self__.directpath_gen2_allowed = directpath_gen2_allowed
        """
        Allow VMDirectPath Gen2 for the ports
        for which this policy applies to.
        """
        __props__['directpathGen2Allowed'] = directpath_gen2_allowed

        if egress_shaping_average_bandwidth and not isinstance(egress_shaping_average_bandwidth, int):
            raise TypeError('Expected property egress_shaping_average_bandwidth to be a int')
        __self__.egress_shaping_average_bandwidth = egress_shaping_average_bandwidth
        """
        The average bandwidth in bits
        per second if egress traffic shaping is enabled on the port.
        """
        __props__['egressShapingAverageBandwidth'] = egress_shaping_average_bandwidth

        if egress_shaping_burst_size and not isinstance(egress_shaping_burst_size, int):
            raise TypeError('Expected property egress_shaping_burst_size to be a int')
        __self__.egress_shaping_burst_size = egress_shaping_burst_size
        """
        The maximum burst size allowed in
        bytes if egress traffic shaping is enabled on the port.
        """
        __props__['egressShapingBurstSize'] = egress_shaping_burst_size

        if egress_shaping_enabled and not isinstance(egress_shaping_enabled, bool):
            raise TypeError('Expected property egress_shaping_enabled to be a bool')
        __self__.egress_shaping_enabled = egress_shaping_enabled
        """
        `true` if the traffic shaper is enabled
        on the port for egress traffic.
        """
        __props__['egressShapingEnabled'] = egress_shaping_enabled

        if egress_shaping_peak_bandwidth and not isinstance(egress_shaping_peak_bandwidth, int):
            raise TypeError('Expected property egress_shaping_peak_bandwidth to be a int')
        __self__.egress_shaping_peak_bandwidth = egress_shaping_peak_bandwidth
        """
        The peak bandwidth during bursts
        in bits per second if egress traffic shaping is enabled on the port.
        """
        __props__['egressShapingPeakBandwidth'] = egress_shaping_peak_bandwidth

        if failback and not isinstance(failback, bool):
            raise TypeError('Expected property failback to be a bool')
        __self__.failback = failback
        """
        If `true`, the teaming policy will re-activate failed
        uplinks higher in precedence when they come back up.
        """
        __props__['failback'] = failback

        if faulttolerance_maximum_mbit and not isinstance(faulttolerance_maximum_mbit, int):
            raise TypeError('Expected property faulttolerance_maximum_mbit to be a int')
        __self__.faulttolerance_maximum_mbit = faulttolerance_maximum_mbit
        """
        The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.
        """
        __props__['faulttoleranceMaximumMbit'] = faulttolerance_maximum_mbit

        if faulttolerance_reservation_mbit and not isinstance(faulttolerance_reservation_mbit, int):
            raise TypeError('Expected property faulttolerance_reservation_mbit to be a int')
        __self__.faulttolerance_reservation_mbit = faulttolerance_reservation_mbit
        """
        The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.
        """
        __props__['faulttoleranceReservationMbit'] = faulttolerance_reservation_mbit

        if faulttolerance_share_count and not isinstance(faulttolerance_share_count, int):
            raise TypeError('Expected property faulttolerance_share_count to be a int')
        __self__.faulttolerance_share_count = faulttolerance_share_count
        """
        The amount of shares to allocate to the faultTolerance traffic class for a custom share level.
        """
        __props__['faulttoleranceShareCount'] = faulttolerance_share_count

        if faulttolerance_share_level and not isinstance(faulttolerance_share_level, basestring):
            raise TypeError('Expected property faulttolerance_share_level to be a basestring')
        __self__.faulttolerance_share_level = faulttolerance_share_level
        """
        The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.
        """
        __props__['faulttoleranceShareLevel'] = faulttolerance_share_level

        if folder and not isinstance(folder, basestring):
            raise TypeError('Expected property folder to be a basestring')
        __self__.folder = folder
        """
        The folder to create the DVS in. Forces a new resource
        if changed.
        """
        __props__['folder'] = folder

        if hbr_maximum_mbit and not isinstance(hbr_maximum_mbit, int):
            raise TypeError('Expected property hbr_maximum_mbit to be a int')
        __self__.hbr_maximum_mbit = hbr_maximum_mbit
        """
        The maximum allowed usage for the hbr traffic class, in Mbits/sec.
        """
        __props__['hbrMaximumMbit'] = hbr_maximum_mbit

        if hbr_reservation_mbit and not isinstance(hbr_reservation_mbit, int):
            raise TypeError('Expected property hbr_reservation_mbit to be a int')
        __self__.hbr_reservation_mbit = hbr_reservation_mbit
        """
        The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.
        """
        __props__['hbrReservationMbit'] = hbr_reservation_mbit

        if hbr_share_count and not isinstance(hbr_share_count, int):
            raise TypeError('Expected property hbr_share_count to be a int')
        __self__.hbr_share_count = hbr_share_count
        """
        The amount of shares to allocate to the hbr traffic class for a custom share level.
        """
        __props__['hbrShareCount'] = hbr_share_count

        if hbr_share_level and not isinstance(hbr_share_level, basestring):
            raise TypeError('Expected property hbr_share_level to be a basestring')
        __self__.hbr_share_level = hbr_share_level
        """
        The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.
        """
        __props__['hbrShareLevel'] = hbr_share_level

        if hosts and not isinstance(hosts, list):
            raise TypeError('Expected property hosts to be a list')
        __self__.hosts = hosts
        """
        Use the `host` block to declare a host specification. The
        options are:
        """
        __props__['hosts'] = hosts

        if ingress_shaping_average_bandwidth and not isinstance(ingress_shaping_average_bandwidth, int):
            raise TypeError('Expected property ingress_shaping_average_bandwidth to be a int')
        __self__.ingress_shaping_average_bandwidth = ingress_shaping_average_bandwidth
        """
        The average bandwidth in
        bits per second if ingress traffic shaping is enabled on the port.
        """
        __props__['ingressShapingAverageBandwidth'] = ingress_shaping_average_bandwidth

        if ingress_shaping_burst_size and not isinstance(ingress_shaping_burst_size, int):
            raise TypeError('Expected property ingress_shaping_burst_size to be a int')
        __self__.ingress_shaping_burst_size = ingress_shaping_burst_size
        """
        The maximum burst size allowed in
        bytes if ingress traffic shaping is enabled on the port.
        """
        __props__['ingressShapingBurstSize'] = ingress_shaping_burst_size

        if ingress_shaping_enabled and not isinstance(ingress_shaping_enabled, bool):
            raise TypeError('Expected property ingress_shaping_enabled to be a bool')
        __self__.ingress_shaping_enabled = ingress_shaping_enabled
        """
        `true` if the traffic shaper is
        enabled on the port for ingress traffic.
        """
        __props__['ingressShapingEnabled'] = ingress_shaping_enabled

        if ingress_shaping_peak_bandwidth and not isinstance(ingress_shaping_peak_bandwidth, int):
            raise TypeError('Expected property ingress_shaping_peak_bandwidth to be a int')
        __self__.ingress_shaping_peak_bandwidth = ingress_shaping_peak_bandwidth
        """
        The peak bandwidth during
        bursts in bits per second if ingress traffic shaping is enabled on the port.
        """
        __props__['ingressShapingPeakBandwidth'] = ingress_shaping_peak_bandwidth

        if ipv4_address and not isinstance(ipv4_address, basestring):
            raise TypeError('Expected property ipv4_address to be a basestring')
        __self__.ipv4_address = ipv4_address
        """
        An IPv4 address to identify the switch. This is
        mostly useful when used with the Netflow arguments found
        below.
        """
        __props__['ipv4Address'] = ipv4_address

        if iscsi_maximum_mbit and not isinstance(iscsi_maximum_mbit, int):
            raise TypeError('Expected property iscsi_maximum_mbit to be a int')
        __self__.iscsi_maximum_mbit = iscsi_maximum_mbit
        """
        The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.
        """
        __props__['iscsiMaximumMbit'] = iscsi_maximum_mbit

        if iscsi_reservation_mbit and not isinstance(iscsi_reservation_mbit, int):
            raise TypeError('Expected property iscsi_reservation_mbit to be a int')
        __self__.iscsi_reservation_mbit = iscsi_reservation_mbit
        """
        The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.
        """
        __props__['iscsiReservationMbit'] = iscsi_reservation_mbit

        if iscsi_share_count and not isinstance(iscsi_share_count, int):
            raise TypeError('Expected property iscsi_share_count to be a int')
        __self__.iscsi_share_count = iscsi_share_count
        """
        The amount of shares to allocate to the iSCSI traffic class for a custom share level.
        """
        __props__['iscsiShareCount'] = iscsi_share_count

        if iscsi_share_level and not isinstance(iscsi_share_level, basestring):
            raise TypeError('Expected property iscsi_share_level to be a basestring')
        __self__.iscsi_share_level = iscsi_share_level
        """
        The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.
        """
        __props__['iscsiShareLevel'] = iscsi_share_level

        if lacp_api_version and not isinstance(lacp_api_version, basestring):
            raise TypeError('Expected property lacp_api_version to be a basestring')
        __self__.lacp_api_version = lacp_api_version
        """
        The Link Aggregation Control Protocol group
        version to use with the switch. Possible values are `singleLag` and
        `multipleLag`.
        """
        __props__['lacpApiVersion'] = lacp_api_version

        if lacp_enabled and not isinstance(lacp_enabled, bool):
            raise TypeError('Expected property lacp_enabled to be a bool')
        __self__.lacp_enabled = lacp_enabled
        """
        Enables LACP for the ports that this policy
        applies to.
        """
        __props__['lacpEnabled'] = lacp_enabled

        if lacp_mode and not isinstance(lacp_mode, basestring):
            raise TypeError('Expected property lacp_mode to be a basestring')
        __self__.lacp_mode = lacp_mode
        """
        The LACP mode. Can be one of `active` or `passive`.
        """
        __props__['lacpMode'] = lacp_mode

        if link_discovery_operation and not isinstance(link_discovery_operation, basestring):
            raise TypeError('Expected property link_discovery_operation to be a basestring')
        __self__.link_discovery_operation = link_discovery_operation
        """
        Whether to `advertise` or `listen`
        for link discovery traffic.
        """
        __props__['linkDiscoveryOperation'] = link_discovery_operation

        if link_discovery_protocol and not isinstance(link_discovery_protocol, basestring):
            raise TypeError('Expected property link_discovery_protocol to be a basestring')
        __self__.link_discovery_protocol = link_discovery_protocol
        """
        The discovery protocol type. Valid
        types are `cdp` and `lldp`.
        """
        __props__['linkDiscoveryProtocol'] = link_discovery_protocol

        if management_maximum_mbit and not isinstance(management_maximum_mbit, int):
            raise TypeError('Expected property management_maximum_mbit to be a int')
        __self__.management_maximum_mbit = management_maximum_mbit
        """
        The maximum allowed usage for the management traffic class, in Mbits/sec.
        """
        __props__['managementMaximumMbit'] = management_maximum_mbit

        if management_reservation_mbit and not isinstance(management_reservation_mbit, int):
            raise TypeError('Expected property management_reservation_mbit to be a int')
        __self__.management_reservation_mbit = management_reservation_mbit
        """
        The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.
        """
        __props__['managementReservationMbit'] = management_reservation_mbit

        if management_share_count and not isinstance(management_share_count, int):
            raise TypeError('Expected property management_share_count to be a int')
        __self__.management_share_count = management_share_count
        """
        The amount of shares to allocate to the management traffic class for a custom share level.
        """
        __props__['managementShareCount'] = management_share_count

        if management_share_level and not isinstance(management_share_level, basestring):
            raise TypeError('Expected property management_share_level to be a basestring')
        __self__.management_share_level = management_share_level
        """
        The allocation level for the management traffic class. Can be one of high, low, normal, or custom.
        """
        __props__['managementShareLevel'] = management_share_level

        if max_mtu and not isinstance(max_mtu, int):
            raise TypeError('Expected property max_mtu to be a int')
        __self__.max_mtu = max_mtu
        """
        The maximum transmission unit (MTU) for the virtual
        switch.
        """
        __props__['maxMtu'] = max_mtu

        if multicast_filtering_mode and not isinstance(multicast_filtering_mode, basestring):
            raise TypeError('Expected property multicast_filtering_mode to be a basestring')
        __self__.multicast_filtering_mode = multicast_filtering_mode
        """
        The multicast filtering mode to use
        with the switch. Can be one of `legacyFiltering` or `snooping`.
        """
        __props__['multicastFilteringMode'] = multicast_filtering_mode

        if name and not isinstance(name, basestring):
            raise TypeError('Expected property name to be a basestring')
        __self__.name = name
        """
        The name of the distributed virtual switch.
        """
        __props__['name'] = name

        if netflow_active_flow_timeout and not isinstance(netflow_active_flow_timeout, int):
            raise TypeError('Expected property netflow_active_flow_timeout to be a int')
        __self__.netflow_active_flow_timeout = netflow_active_flow_timeout
        """
        The number of seconds after which
        active flows are forced to be exported to the collector. Allowed range is
        `60` to `3600`. Default: `60`.
        """
        __props__['netflowActiveFlowTimeout'] = netflow_active_flow_timeout

        if netflow_collector_ip_address and not isinstance(netflow_collector_ip_address, basestring):
            raise TypeError('Expected property netflow_collector_ip_address to be a basestring')
        __self__.netflow_collector_ip_address = netflow_collector_ip_address
        """
        IP address for the Netflow
        collector, using IPv4 or IPv6. IPv6 is supported in vSphere Distributed
        Switch Version 6.0 or later. Must be set before Netflow can be enabled.
        """
        __props__['netflowCollectorIpAddress'] = netflow_collector_ip_address

        if netflow_collector_port and not isinstance(netflow_collector_port, int):
            raise TypeError('Expected property netflow_collector_port to be a int')
        __self__.netflow_collector_port = netflow_collector_port
        """
        Port for the Netflow collector. This
        must be set before Netflow can be enabled.
        """
        __props__['netflowCollectorPort'] = netflow_collector_port

        if netflow_enabled and not isinstance(netflow_enabled, bool):
            raise TypeError('Expected property netflow_enabled to be a bool')
        __self__.netflow_enabled = netflow_enabled
        """
        Enables Netflow on all ports that this policy
        applies to.
        """
        __props__['netflowEnabled'] = netflow_enabled

        if netflow_idle_flow_timeout and not isinstance(netflow_idle_flow_timeout, int):
            raise TypeError('Expected property netflow_idle_flow_timeout to be a int')
        __self__.netflow_idle_flow_timeout = netflow_idle_flow_timeout
        """
        The number of seconds after which
        idle flows are forced to be exported to the collector. Allowed range is `10`
        to `600`. Default: `15`.
        """
        __props__['netflowIdleFlowTimeout'] = netflow_idle_flow_timeout

        if netflow_internal_flows_only and not isinstance(netflow_internal_flows_only, bool):
            raise TypeError('Expected property netflow_internal_flows_only to be a bool')
        __self__.netflow_internal_flows_only = netflow_internal_flows_only
        """
        Whether to limit analysis to
        traffic that has both source and destination served by the same host.
        Default: `false`.
        """
        __props__['netflowInternalFlowsOnly'] = netflow_internal_flows_only

        if netflow_observation_domain_id and not isinstance(netflow_observation_domain_id, int):
            raise TypeError('Expected property netflow_observation_domain_id to be a int')
        __self__.netflow_observation_domain_id = netflow_observation_domain_id
        """
        The observation domain ID for
        the Netflow collector.
        """
        __props__['netflowObservationDomainId'] = netflow_observation_domain_id

        if netflow_sampling_rate and not isinstance(netflow_sampling_rate, int):
            raise TypeError('Expected property netflow_sampling_rate to be a int')
        __self__.netflow_sampling_rate = netflow_sampling_rate
        """
        The ratio of total number of packets to
        the number of packets analyzed. The default is `0`, which indicates that the
        switch should analyze all packets. The maximum value is `1000`, which
        indicates an analysis rate of 0.001%.
        """
        __props__['netflowSamplingRate'] = netflow_sampling_rate

        if network_resource_control_enabled and not isinstance(network_resource_control_enabled, bool):
            raise TypeError('Expected property network_resource_control_enabled to be a bool')
        __self__.network_resource_control_enabled = network_resource_control_enabled
        """
        Set to `true` to enable
        network I/O control. Default: `false`.
        """
        __props__['networkResourceControlEnabled'] = network_resource_control_enabled

        if network_resource_control_version and not isinstance(network_resource_control_version, basestring):
            raise TypeError('Expected property network_resource_control_version to be a basestring')
        __self__.network_resource_control_version = network_resource_control_version
        """
        The version of network I/O
        control to use. Can be one of `version2` or `version3`. Default: `version2`.
        """
        __props__['networkResourceControlVersion'] = network_resource_control_version

        if nfs_maximum_mbit and not isinstance(nfs_maximum_mbit, int):
            raise TypeError('Expected property nfs_maximum_mbit to be a int')
        __self__.nfs_maximum_mbit = nfs_maximum_mbit
        """
        The maximum allowed usage for the nfs traffic class, in Mbits/sec.
        """
        __props__['nfsMaximumMbit'] = nfs_maximum_mbit

        if nfs_reservation_mbit and not isinstance(nfs_reservation_mbit, int):
            raise TypeError('Expected property nfs_reservation_mbit to be a int')
        __self__.nfs_reservation_mbit = nfs_reservation_mbit
        """
        The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.
        """
        __props__['nfsReservationMbit'] = nfs_reservation_mbit

        if nfs_share_count and not isinstance(nfs_share_count, int):
            raise TypeError('Expected property nfs_share_count to be a int')
        __self__.nfs_share_count = nfs_share_count
        """
        The amount of shares to allocate to the nfs traffic class for a custom share level.
        """
        __props__['nfsShareCount'] = nfs_share_count

        if nfs_share_level and not isinstance(nfs_share_level, basestring):
            raise TypeError('Expected property nfs_share_level to be a basestring')
        __self__.nfs_share_level = nfs_share_level
        """
        The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.
        """
        __props__['nfsShareLevel'] = nfs_share_level

        if notify_switches and not isinstance(notify_switches, bool):
            raise TypeError('Expected property notify_switches to be a bool')
        __self__.notify_switches = notify_switches
        """
        If `true`, the teaming policy will notify the
        broadcast network of an uplink failover, triggering cache updates.
        """
        __props__['notifySwitches'] = notify_switches

        if port_private_secondary_vlan_id and not isinstance(port_private_secondary_vlan_id, int):
            raise TypeError('Expected property port_private_secondary_vlan_id to be a int')
        __self__.port_private_secondary_vlan_id = port_private_secondary_vlan_id
        """
        Used to define a secondary VLAN
        ID when using private VLANs.
        """
        __props__['portPrivateSecondaryVlanId'] = port_private_secondary_vlan_id

        if standby_uplinks and not isinstance(standby_uplinks, list):
            raise TypeError('Expected property standby_uplinks to be a list')
        __self__.standby_uplinks = standby_uplinks
        """
        A list of standby uplinks to be used in
        failover. These uplinks need to match the definitions in the
        `uplinks` DVS argument. See
        here for more details.
        """
        __props__['standbyUplinks'] = standby_uplinks

        if tags and not isinstance(tags, list):
            raise TypeError('Expected property tags to be a list')
        __self__.tags = tags
        """
        The IDs of any tags to attach to this resource. See
        [here][docs-applying-tags] for a reference on how to apply tags.
        """
        __props__['tags'] = tags

        if teaming_policy and not isinstance(teaming_policy, basestring):
            raise TypeError('Expected property teaming_policy to be a basestring')
        __self__.teaming_policy = teaming_policy
        """
        The uplink teaming policy. Can be one of
        `loadbalance_ip`, `loadbalance_srcmac`, `loadbalance_srcid`, or
        `failover_explicit`.
        """
        __props__['teamingPolicy'] = teaming_policy

        if tx_uplink and not isinstance(tx_uplink, bool):
            raise TypeError('Expected property tx_uplink to be a bool')
        __self__.tx_uplink = tx_uplink
        """
        Forward all traffic transmitted by ports for which
        this policy applies to its DVS uplinks.
        """
        __props__['txUplink'] = tx_uplink

        if uplinks and not isinstance(uplinks, list):
            raise TypeError('Expected property uplinks to be a list')
        __self__.uplinks = uplinks
        """
        A list of strings that uniquely identifies the names
        of the uplinks on the DVS across hosts. The number of items in this list
        controls the number of uplinks that exist on the DVS, in addition to the
        names.  See here for an example on how to
        use this option.
        """
        __props__['uplinks'] = uplinks

        if vdp_maximum_mbit and not isinstance(vdp_maximum_mbit, int):
            raise TypeError('Expected property vdp_maximum_mbit to be a int')
        __self__.vdp_maximum_mbit = vdp_maximum_mbit
        """
        The maximum allowed usage for the vdp traffic class, in Mbits/sec.
        """
        __props__['vdpMaximumMbit'] = vdp_maximum_mbit

        if vdp_reservation_mbit and not isinstance(vdp_reservation_mbit, int):
            raise TypeError('Expected property vdp_reservation_mbit to be a int')
        __self__.vdp_reservation_mbit = vdp_reservation_mbit
        """
        The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.
        """
        __props__['vdpReservationMbit'] = vdp_reservation_mbit

        if vdp_share_count and not isinstance(vdp_share_count, int):
            raise TypeError('Expected property vdp_share_count to be a int')
        __self__.vdp_share_count = vdp_share_count
        """
        The amount of shares to allocate to the vdp traffic class for a custom share level.
        """
        __props__['vdpShareCount'] = vdp_share_count

        if vdp_share_level and not isinstance(vdp_share_level, basestring):
            raise TypeError('Expected property vdp_share_level to be a basestring')
        __self__.vdp_share_level = vdp_share_level
        """
        The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.
        """
        __props__['vdpShareLevel'] = vdp_share_level

        if version and not isinstance(version, basestring):
            raise TypeError('Expected property version to be a basestring')
        __self__.version = version
        """
        - The version of the DVS to create. The default is to
        create the DVS at the latest version supported by the version of vSphere
        being used. A DVS can be upgraded to another version, but cannot be
        downgraded.
        """
        __props__['version'] = version

        if virtualmachine_maximum_mbit and not isinstance(virtualmachine_maximum_mbit, int):
            raise TypeError('Expected property virtualmachine_maximum_mbit to be a int')
        __self__.virtualmachine_maximum_mbit = virtualmachine_maximum_mbit
        """
        The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.
        """
        __props__['virtualmachineMaximumMbit'] = virtualmachine_maximum_mbit

        if virtualmachine_reservation_mbit and not isinstance(virtualmachine_reservation_mbit, int):
            raise TypeError('Expected property virtualmachine_reservation_mbit to be a int')
        __self__.virtualmachine_reservation_mbit = virtualmachine_reservation_mbit
        """
        The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.
        """
        __props__['virtualmachineReservationMbit'] = virtualmachine_reservation_mbit

        if virtualmachine_share_count and not isinstance(virtualmachine_share_count, int):
            raise TypeError('Expected property virtualmachine_share_count to be a int')
        __self__.virtualmachine_share_count = virtualmachine_share_count
        """
        The amount of shares to allocate to the virtualMachine traffic class for a custom share level.
        """
        __props__['virtualmachineShareCount'] = virtualmachine_share_count

        if virtualmachine_share_level and not isinstance(virtualmachine_share_level, basestring):
            raise TypeError('Expected property virtualmachine_share_level to be a basestring')
        __self__.virtualmachine_share_level = virtualmachine_share_level
        """
        The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.
        """
        __props__['virtualmachineShareLevel'] = virtualmachine_share_level

        if vlan_id and not isinstance(vlan_id, int):
            raise TypeError('Expected property vlan_id to be a int')
        __self__.vlan_id = vlan_id
        """
        The VLAN ID for single VLAN mode. 0 denotes no VLAN.
        """
        __props__['vlanId'] = vlan_id

        if vlan_ranges and not isinstance(vlan_ranges, list):
            raise TypeError('Expected property vlan_ranges to be a list')
        __self__.vlan_ranges = vlan_ranges
        """
        Used to denote VLAN trunking. Use the `min_vlan`
        and `max_vlan` sub-arguments to define the tagged VLAN range. Multiple
        `vlan_range` definitions are allowed, but they must not overlap. Example
        below:
        """
        __props__['vlanRanges'] = vlan_ranges

        if vmotion_maximum_mbit and not isinstance(vmotion_maximum_mbit, int):
            raise TypeError('Expected property vmotion_maximum_mbit to be a int')
        __self__.vmotion_maximum_mbit = vmotion_maximum_mbit
        """
        The maximum allowed usage for the vmotion traffic class, in Mbits/sec.
        """
        __props__['vmotionMaximumMbit'] = vmotion_maximum_mbit

        if vmotion_reservation_mbit and not isinstance(vmotion_reservation_mbit, int):
            raise TypeError('Expected property vmotion_reservation_mbit to be a int')
        __self__.vmotion_reservation_mbit = vmotion_reservation_mbit
        """
        The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.
        """
        __props__['vmotionReservationMbit'] = vmotion_reservation_mbit

        if vmotion_share_count and not isinstance(vmotion_share_count, int):
            raise TypeError('Expected property vmotion_share_count to be a int')
        __self__.vmotion_share_count = vmotion_share_count
        """
        The amount of shares to allocate to the vmotion traffic class for a custom share level.
        """
        __props__['vmotionShareCount'] = vmotion_share_count

        if vmotion_share_level and not isinstance(vmotion_share_level, basestring):
            raise TypeError('Expected property vmotion_share_level to be a basestring')
        __self__.vmotion_share_level = vmotion_share_level
        """
        The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.
        """
        __props__['vmotionShareLevel'] = vmotion_share_level

        if vsan_maximum_mbit and not isinstance(vsan_maximum_mbit, int):
            raise TypeError('Expected property vsan_maximum_mbit to be a int')
        __self__.vsan_maximum_mbit = vsan_maximum_mbit
        """
        The maximum allowed usage for the vsan traffic class, in Mbits/sec.
        """
        __props__['vsanMaximumMbit'] = vsan_maximum_mbit

        if vsan_reservation_mbit and not isinstance(vsan_reservation_mbit, int):
            raise TypeError('Expected property vsan_reservation_mbit to be a int')
        __self__.vsan_reservation_mbit = vsan_reservation_mbit
        """
        The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.
        """
        __props__['vsanReservationMbit'] = vsan_reservation_mbit

        if vsan_share_count and not isinstance(vsan_share_count, int):
            raise TypeError('Expected property vsan_share_count to be a int')
        __self__.vsan_share_count = vsan_share_count
        """
        The amount of shares to allocate to the vsan traffic class for a custom share level.
        """
        __props__['vsanShareCount'] = vsan_share_count

        if vsan_share_level and not isinstance(vsan_share_level, basestring):
            raise TypeError('Expected property vsan_share_level to be a basestring')
        __self__.vsan_share_level = vsan_share_level
        """
        The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.
        """
        __props__['vsanShareLevel'] = vsan_share_level

        __self__.config_version = pulumi.runtime.UNKNOWN
        """
        The version string of the configuration that this spec is trying to change.
        """

        super(DistributedVirtualSwitch, __self__).__init__(
            'vsphere:index/distributedVirtualSwitch:DistributedVirtualSwitch',
            __name__,
            __props__,
            __opts__)

    def set_outputs(self, outs):
        if 'activeUplinks' in outs:
            self.active_uplinks = outs['activeUplinks']
        if 'allowForgedTransmits' in outs:
            self.allow_forged_transmits = outs['allowForgedTransmits']
        if 'allowMacChanges' in outs:
            self.allow_mac_changes = outs['allowMacChanges']
        if 'allowPromiscuous' in outs:
            self.allow_promiscuous = outs['allowPromiscuous']
        if 'blockAllPorts' in outs:
            self.block_all_ports = outs['blockAllPorts']
        if 'checkBeacon' in outs:
            self.check_beacon = outs['checkBeacon']
        if 'configVersion' in outs:
            self.config_version = outs['configVersion']
        if 'contactDetail' in outs:
            self.contact_detail = outs['contactDetail']
        if 'contactName' in outs:
            self.contact_name = outs['contactName']
        if 'customAttributes' in outs:
            self.custom_attributes = outs['customAttributes']
        if 'datacenterId' in outs:
            self.datacenter_id = outs['datacenterId']
        if 'description' in outs:
            self.description = outs['description']
        if 'directpathGen2Allowed' in outs:
            self.directpath_gen2_allowed = outs['directpathGen2Allowed']
        if 'egressShapingAverageBandwidth' in outs:
            self.egress_shaping_average_bandwidth = outs['egressShapingAverageBandwidth']
        if 'egressShapingBurstSize' in outs:
            self.egress_shaping_burst_size = outs['egressShapingBurstSize']
        if 'egressShapingEnabled' in outs:
            self.egress_shaping_enabled = outs['egressShapingEnabled']
        if 'egressShapingPeakBandwidth' in outs:
            self.egress_shaping_peak_bandwidth = outs['egressShapingPeakBandwidth']
        if 'failback' in outs:
            self.failback = outs['failback']
        if 'faulttoleranceMaximumMbit' in outs:
            self.faulttolerance_maximum_mbit = outs['faulttoleranceMaximumMbit']
        if 'faulttoleranceReservationMbit' in outs:
            self.faulttolerance_reservation_mbit = outs['faulttoleranceReservationMbit']
        if 'faulttoleranceShareCount' in outs:
            self.faulttolerance_share_count = outs['faulttoleranceShareCount']
        if 'faulttoleranceShareLevel' in outs:
            self.faulttolerance_share_level = outs['faulttoleranceShareLevel']
        if 'folder' in outs:
            self.folder = outs['folder']
        if 'hbrMaximumMbit' in outs:
            self.hbr_maximum_mbit = outs['hbrMaximumMbit']
        if 'hbrReservationMbit' in outs:
            self.hbr_reservation_mbit = outs['hbrReservationMbit']
        if 'hbrShareCount' in outs:
            self.hbr_share_count = outs['hbrShareCount']
        if 'hbrShareLevel' in outs:
            self.hbr_share_level = outs['hbrShareLevel']
        if 'hosts' in outs:
            self.hosts = outs['hosts']
        if 'ingressShapingAverageBandwidth' in outs:
            self.ingress_shaping_average_bandwidth = outs['ingressShapingAverageBandwidth']
        if 'ingressShapingBurstSize' in outs:
            self.ingress_shaping_burst_size = outs['ingressShapingBurstSize']
        if 'ingressShapingEnabled' in outs:
            self.ingress_shaping_enabled = outs['ingressShapingEnabled']
        if 'ingressShapingPeakBandwidth' in outs:
            self.ingress_shaping_peak_bandwidth = outs['ingressShapingPeakBandwidth']
        if 'ipv4Address' in outs:
            self.ipv4_address = outs['ipv4Address']
        if 'iscsiMaximumMbit' in outs:
            self.iscsi_maximum_mbit = outs['iscsiMaximumMbit']
        if 'iscsiReservationMbit' in outs:
            self.iscsi_reservation_mbit = outs['iscsiReservationMbit']
        if 'iscsiShareCount' in outs:
            self.iscsi_share_count = outs['iscsiShareCount']
        if 'iscsiShareLevel' in outs:
            self.iscsi_share_level = outs['iscsiShareLevel']
        if 'lacpApiVersion' in outs:
            self.lacp_api_version = outs['lacpApiVersion']
        if 'lacpEnabled' in outs:
            self.lacp_enabled = outs['lacpEnabled']
        if 'lacpMode' in outs:
            self.lacp_mode = outs['lacpMode']
        if 'linkDiscoveryOperation' in outs:
            self.link_discovery_operation = outs['linkDiscoveryOperation']
        if 'linkDiscoveryProtocol' in outs:
            self.link_discovery_protocol = outs['linkDiscoveryProtocol']
        if 'managementMaximumMbit' in outs:
            self.management_maximum_mbit = outs['managementMaximumMbit']
        if 'managementReservationMbit' in outs:
            self.management_reservation_mbit = outs['managementReservationMbit']
        if 'managementShareCount' in outs:
            self.management_share_count = outs['managementShareCount']
        if 'managementShareLevel' in outs:
            self.management_share_level = outs['managementShareLevel']
        if 'maxMtu' in outs:
            self.max_mtu = outs['maxMtu']
        if 'multicastFilteringMode' in outs:
            self.multicast_filtering_mode = outs['multicastFilteringMode']
        if 'name' in outs:
            self.name = outs['name']
        if 'netflowActiveFlowTimeout' in outs:
            self.netflow_active_flow_timeout = outs['netflowActiveFlowTimeout']
        if 'netflowCollectorIpAddress' in outs:
            self.netflow_collector_ip_address = outs['netflowCollectorIpAddress']
        if 'netflowCollectorPort' in outs:
            self.netflow_collector_port = outs['netflowCollectorPort']
        if 'netflowEnabled' in outs:
            self.netflow_enabled = outs['netflowEnabled']
        if 'netflowIdleFlowTimeout' in outs:
            self.netflow_idle_flow_timeout = outs['netflowIdleFlowTimeout']
        if 'netflowInternalFlowsOnly' in outs:
            self.netflow_internal_flows_only = outs['netflowInternalFlowsOnly']
        if 'netflowObservationDomainId' in outs:
            self.netflow_observation_domain_id = outs['netflowObservationDomainId']
        if 'netflowSamplingRate' in outs:
            self.netflow_sampling_rate = outs['netflowSamplingRate']
        if 'networkResourceControlEnabled' in outs:
            self.network_resource_control_enabled = outs['networkResourceControlEnabled']
        if 'networkResourceControlVersion' in outs:
            self.network_resource_control_version = outs['networkResourceControlVersion']
        if 'nfsMaximumMbit' in outs:
            self.nfs_maximum_mbit = outs['nfsMaximumMbit']
        if 'nfsReservationMbit' in outs:
            self.nfs_reservation_mbit = outs['nfsReservationMbit']
        if 'nfsShareCount' in outs:
            self.nfs_share_count = outs['nfsShareCount']
        if 'nfsShareLevel' in outs:
            self.nfs_share_level = outs['nfsShareLevel']
        if 'notifySwitches' in outs:
            self.notify_switches = outs['notifySwitches']
        if 'portPrivateSecondaryVlanId' in outs:
            self.port_private_secondary_vlan_id = outs['portPrivateSecondaryVlanId']
        if 'standbyUplinks' in outs:
            self.standby_uplinks = outs['standbyUplinks']
        if 'tags' in outs:
            self.tags = outs['tags']
        if 'teamingPolicy' in outs:
            self.teaming_policy = outs['teamingPolicy']
        if 'txUplink' in outs:
            self.tx_uplink = outs['txUplink']
        if 'uplinks' in outs:
            self.uplinks = outs['uplinks']
        if 'vdpMaximumMbit' in outs:
            self.vdp_maximum_mbit = outs['vdpMaximumMbit']
        if 'vdpReservationMbit' in outs:
            self.vdp_reservation_mbit = outs['vdpReservationMbit']
        if 'vdpShareCount' in outs:
            self.vdp_share_count = outs['vdpShareCount']
        if 'vdpShareLevel' in outs:
            self.vdp_share_level = outs['vdpShareLevel']
        if 'version' in outs:
            self.version = outs['version']
        if 'virtualmachineMaximumMbit' in outs:
            self.virtualmachine_maximum_mbit = outs['virtualmachineMaximumMbit']
        if 'virtualmachineReservationMbit' in outs:
            self.virtualmachine_reservation_mbit = outs['virtualmachineReservationMbit']
        if 'virtualmachineShareCount' in outs:
            self.virtualmachine_share_count = outs['virtualmachineShareCount']
        if 'virtualmachineShareLevel' in outs:
            self.virtualmachine_share_level = outs['virtualmachineShareLevel']
        if 'vlanId' in outs:
            self.vlan_id = outs['vlanId']
        if 'vlanRanges' in outs:
            self.vlan_ranges = outs['vlanRanges']
        if 'vmotionMaximumMbit' in outs:
            self.vmotion_maximum_mbit = outs['vmotionMaximumMbit']
        if 'vmotionReservationMbit' in outs:
            self.vmotion_reservation_mbit = outs['vmotionReservationMbit']
        if 'vmotionShareCount' in outs:
            self.vmotion_share_count = outs['vmotionShareCount']
        if 'vmotionShareLevel' in outs:
            self.vmotion_share_level = outs['vmotionShareLevel']
        if 'vsanMaximumMbit' in outs:
            self.vsan_maximum_mbit = outs['vsanMaximumMbit']
        if 'vsanReservationMbit' in outs:
            self.vsan_reservation_mbit = outs['vsanReservationMbit']
        if 'vsanShareCount' in outs:
            self.vsan_share_count = outs['vsanShareCount']
        if 'vsanShareLevel' in outs:
            self.vsan_share_level = outs['vsanShareLevel']
