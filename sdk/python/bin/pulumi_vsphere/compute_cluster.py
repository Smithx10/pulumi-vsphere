# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import pulumi
import pulumi.runtime

class ComputeCluster(pulumi.CustomResource):
    """
    -> **A note on the naming of this resource:** VMware refers to clusters of
    hosts in the UI and documentation as _clusters_, _HA clusters_, or _DRS
    clusters_. All of these refer to the same kind of resource (with the latter two
    referring to specific features of clustering). In Terraform, we use
    `vsphere_compute_cluster` to differentiate host clusters from _datastore
    clusters_, which are clusters of datastores that can be used to distribute load
    and ensure fault tolerance via distribution of virtual machines. Datastore
    clusters can also be managed through Terraform, via the
    [`vsphere_datastore_cluster` resource][docs-r-vsphere-datastore-cluster].
    
    [docs-r-vsphere-datastore-cluster]: /docs/providers/vsphere/r/datastore_cluster.html
    
    The `vsphere_compute_cluster` resource can be used to create and manage
    clusters of hosts allowing for resource control of compute resources, load
    balancing through DRS, and high availability through vSphere HA.
    
    For more information on vSphere clusters and DRS, see [this
    page][ref-vsphere-drs-clusters]. For more information on vSphere HA, see [this
    page][ref-vsphere-ha-clusters].
    
    [ref-vsphere-drs-clusters]: https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.resmgmt.doc/GUID-8ACF3502-5314-469F-8CC9-4A9BD5925BC2.html
    [ref-vsphere-ha-clusters]: https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.avail.doc/GUID-5432CA24-14F1-44E3-87FB-61D937831CF6.html
    
    ~> **NOTE:** This resource requires vCenter and is not available on direct ESXi
    connections.
    
    ~> **NOTE:** vSphere DRS requires a vSphere Enterprise Plus license.
    """
    def __init__(__self__, __name__, __opts__=None, custom_attributes=None, datacenter_id=None, dpm_automation_level=None, dpm_enabled=None, dpm_threshold=None, drs_advanced_options=None, drs_automation_level=None, drs_enable_predictive_drs=None, drs_enable_vm_overrides=None, drs_enabled=None, drs_migration_threshold=None, folder=None, force_evacuate_on_destroy=None, ha_admission_control_failover_host_system_ids=None, ha_admission_control_host_failure_tolerance=None, ha_admission_control_performance_tolerance=None, ha_admission_control_policy=None, ha_admission_control_resource_percentage_auto_compute=None, ha_admission_control_resource_percentage_cpu=None, ha_admission_control_resource_percentage_memory=None, ha_admission_control_slot_policy_explicit_cpu=None, ha_admission_control_slot_policy_explicit_memory=None, ha_admission_control_slot_policy_use_explicit_size=None, ha_advanced_options=None, ha_datastore_apd_recovery_action=None, ha_datastore_apd_response=None, ha_datastore_apd_response_delay=None, ha_datastore_pdl_response=None, ha_enabled=None, ha_heartbeat_datastore_ids=None, ha_heartbeat_datastore_policy=None, ha_host_isolation_response=None, ha_host_monitoring=None, ha_vm_component_protection=None, ha_vm_dependency_restart_condition=None, ha_vm_failure_interval=None, ha_vm_maximum_failure_window=None, ha_vm_maximum_resets=None, ha_vm_minimum_uptime=None, ha_vm_monitoring=None, ha_vm_restart_additional_delay=None, ha_vm_restart_priority=None, ha_vm_restart_timeout=None, host_cluster_exit_timeout=None, host_system_ids=None, name=None, proactive_ha_automation_level=None, proactive_ha_enabled=None, proactive_ha_moderate_remediation=None, proactive_ha_provider_ids=None, proactive_ha_severe_remediation=None, tags=None):
        """Create a ComputeCluster resource with the given unique name, props, and options."""
        if not __name__:
            raise TypeError('Missing resource name argument (for URN creation)')
        if not isinstance(__name__, basestring):
            raise TypeError('Expected resource name to be a string')
        if __opts__ and not isinstance(__opts__, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')

        __props__ = dict()

        if custom_attributes and not isinstance(custom_attributes, dict):
            raise TypeError('Expected property custom_attributes to be a dict')
        __self__.custom_attributes = custom_attributes
        """
        A map of custom attribute ids to attribute
        value strings to set for the datastore cluster. See
        [here][docs-setting-custom-attributes] for a reference on how to set values
        for custom attributes.
        """
        __props__['customAttributes'] = custom_attributes

        if not datacenter_id:
            raise TypeError('Missing required property datacenter_id')
        elif not isinstance(datacenter_id, basestring):
            raise TypeError('Expected property datacenter_id to be a basestring')
        __self__.datacenter_id = datacenter_id
        """
        The [managed object ID][docs-about-morefs] of
        the datacenter to create the cluster in. Forces a new resource if changed.
        """
        __props__['datacenterId'] = datacenter_id

        if dpm_automation_level and not isinstance(dpm_automation_level, basestring):
            raise TypeError('Expected property dpm_automation_level to be a basestring')
        __self__.dpm_automation_level = dpm_automation_level
        """
        The automation level for host power
        operations in this cluster. Can be one of `manual` or `automated`. Default:
        `manual`.
        """
        __props__['dpmAutomationLevel'] = dpm_automation_level

        if dpm_enabled and not isinstance(dpm_enabled, bool):
            raise TypeError('Expected property dpm_enabled to be a bool')
        __self__.dpm_enabled = dpm_enabled
        """
        Enable DPM support for DRS in this cluster.
        Requires `drs_enabled` to be `true` in order to be effective.
        Default: `false`.
        """
        __props__['dpmEnabled'] = dpm_enabled

        if dpm_threshold and not isinstance(dpm_threshold, int):
            raise TypeError('Expected property dpm_threshold to be a int')
        __self__.dpm_threshold = dpm_threshold
        """
        A value between `1` and `5` indicating the
        threshold of load within the cluster that influences host power operations.
        This affects both power on and power off operations - a lower setting will
        tolerate more of a surplus/deficit than a higher setting. Default: `3`.
        """
        __props__['dpmThreshold'] = dpm_threshold

        if drs_advanced_options and not isinstance(drs_advanced_options, dict):
            raise TypeError('Expected property drs_advanced_options to be a dict')
        __self__.drs_advanced_options = drs_advanced_options
        """
        A key/value map that specifies advanced
        options for DRS and DPM.
        """
        __props__['drsAdvancedOptions'] = drs_advanced_options

        if drs_automation_level and not isinstance(drs_automation_level, basestring):
            raise TypeError('Expected property drs_automation_level to be a basestring')
        __self__.drs_automation_level = drs_automation_level
        """
        The default automation level for all
        virtual machines in this cluster. Can be one of `manual`,
        `partiallyAutomated`, or `fullyAutomated`. Default: `manual`.
        """
        __props__['drsAutomationLevel'] = drs_automation_level

        if drs_enable_predictive_drs and not isinstance(drs_enable_predictive_drs, bool):
            raise TypeError('Expected property drs_enable_predictive_drs to be a bool')
        __self__.drs_enable_predictive_drs = drs_enable_predictive_drs
        """
        When `true`, enables DRS to use data
        from [vRealize Operations Manager][ref-vsphere-vro] to make proactive DRS
        recommendations. <sup>\*</sup>
        """
        __props__['drsEnablePredictiveDrs'] = drs_enable_predictive_drs

        if drs_enable_vm_overrides and not isinstance(drs_enable_vm_overrides, bool):
            raise TypeError('Expected property drs_enable_vm_overrides to be a bool')
        __self__.drs_enable_vm_overrides = drs_enable_vm_overrides
        """
        Allow individual DRS overrides to be
        set for virtual machines in the cluster. Default: `true`.
        """
        __props__['drsEnableVmOverrides'] = drs_enable_vm_overrides

        if drs_enabled and not isinstance(drs_enabled, bool):
            raise TypeError('Expected property drs_enabled to be a bool')
        __self__.drs_enabled = drs_enabled
        """
        Enable DRS for this cluster. Default: `false`.
        """
        __props__['drsEnabled'] = drs_enabled

        if drs_migration_threshold and not isinstance(drs_migration_threshold, int):
            raise TypeError('Expected property drs_migration_threshold to be a int')
        __self__.drs_migration_threshold = drs_migration_threshold
        """
        A value between `1` and `5` indicating
        the threshold of imbalance tolerated between hosts. A lower setting will
        tolerate more imbalance while a higher setting will tolerate less. Default:
        `3`.
        """
        __props__['drsMigrationThreshold'] = drs_migration_threshold

        if folder and not isinstance(folder, basestring):
            raise TypeError('Expected property folder to be a basestring')
        __self__.folder = folder
        """
        The relative path to a folder to put this cluster in.
        This is a path relative to the datacenter you are deploying the cluster to.
        Example: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,
        Terraform will place a cluster named `terraform-compute-cluster-test` in a
        host folder located at `/dc1/host/foo/bar`, with the final inventory path
        being `/dc1/host/foo/bar/terraform-datastore-cluster-test`.
        """
        __props__['folder'] = folder

        if force_evacuate_on_destroy and not isinstance(force_evacuate_on_destroy, bool):
            raise TypeError('Expected property force_evacuate_on_destroy to be a bool')
        __self__.force_evacuate_on_destroy = force_evacuate_on_destroy
        """
        When destroying the resource, setting this to
        `true` will auto-remove any hosts that are currently a member of the cluster,
        as if they were removed by taking their entry out of `host_system_ids` (see
        below). This is an advanced
        option and should only be used for testing. Default: `false`.
        """
        __props__['forceEvacuateOnDestroy'] = force_evacuate_on_destroy

        if ha_admission_control_failover_host_system_ids and not isinstance(ha_admission_control_failover_host_system_ids, list):
            raise TypeError('Expected property ha_admission_control_failover_host_system_ids to be a list')
        __self__.ha_admission_control_failover_host_system_ids = ha_admission_control_failover_host_system_ids
        """
        Defines the
        [managed object IDs][docs-about-morefs] of hosts to use as dedicated failover
        hosts. These hosts are kept as available as possible - admission control will
        block access to the host, and DRS will ignore the host when making
        recommendations.
        """
        __props__['haAdmissionControlFailoverHostSystemIds'] = ha_admission_control_failover_host_system_ids

        if ha_admission_control_host_failure_tolerance and not isinstance(ha_admission_control_host_failure_tolerance, int):
            raise TypeError('Expected property ha_admission_control_host_failure_tolerance to be a int')
        __self__.ha_admission_control_host_failure_tolerance = ha_admission_control_host_failure_tolerance
        """
        The maximum number
        of failed hosts that admission control tolerates when making decisions on
        whether to permit virtual machine operations. The maximum is one less than
        the number of hosts in the cluster. Default: `1`.
        <sup>\*</sup>
        """
        __props__['haAdmissionControlHostFailureTolerance'] = ha_admission_control_host_failure_tolerance

        if ha_admission_control_performance_tolerance and not isinstance(ha_admission_control_performance_tolerance, int):
            raise TypeError('Expected property ha_admission_control_performance_tolerance to be a int')
        __self__.ha_admission_control_performance_tolerance = ha_admission_control_performance_tolerance
        """
        The percentage of
        resource reduction that a cluster of virtual machines can tolerate in case of
        a failover. A value of 0 produces warnings only, whereas a value of 100
        disables the setting. Default: `100` (disabled).
        """
        __props__['haAdmissionControlPerformanceTolerance'] = ha_admission_control_performance_tolerance

        if ha_admission_control_policy and not isinstance(ha_admission_control_policy, basestring):
            raise TypeError('Expected property ha_admission_control_policy to be a basestring')
        __self__.ha_admission_control_policy = ha_admission_control_policy
        """
        The type of admission control
        policy to use with vSphere HA. Can be one of `resourcePercentage`,
        `slotPolicy`, `failoverHosts`, or `disabled`. Default: `resourcePercentage`.
        """
        __props__['haAdmissionControlPolicy'] = ha_admission_control_policy

        if ha_admission_control_resource_percentage_auto_compute and not isinstance(ha_admission_control_resource_percentage_auto_compute, bool):
            raise TypeError('Expected property ha_admission_control_resource_percentage_auto_compute to be a bool')
        __self__.ha_admission_control_resource_percentage_auto_compute = ha_admission_control_resource_percentage_auto_compute
        """
        
        Automatically determine available resource percentages by subtracting the
        average number of host resources represented by the
        `ha_admission_control_host_failure_tolerance`
        setting from the total amount of resources in the cluster. Disable to supply
        user-defined values. Default: `true`.
        <sup>\*</sup>
        """
        __props__['haAdmissionControlResourcePercentageAutoCompute'] = ha_admission_control_resource_percentage_auto_compute

        if ha_admission_control_resource_percentage_cpu and not isinstance(ha_admission_control_resource_percentage_cpu, int):
            raise TypeError('Expected property ha_admission_control_resource_percentage_cpu to be a int')
        __self__.ha_admission_control_resource_percentage_cpu = ha_admission_control_resource_percentage_cpu
        """
        Controls the
        user-defined percentage of CPU resources in the cluster to reserve for
        failover. Default: `100`.
        """
        __props__['haAdmissionControlResourcePercentageCpu'] = ha_admission_control_resource_percentage_cpu

        if ha_admission_control_resource_percentage_memory and not isinstance(ha_admission_control_resource_percentage_memory, int):
            raise TypeError('Expected property ha_admission_control_resource_percentage_memory to be a int')
        __self__.ha_admission_control_resource_percentage_memory = ha_admission_control_resource_percentage_memory
        """
        Controls the
        user-defined percentage of memory resources in the cluster to reserve for
        failover. Default: `100`.
        """
        __props__['haAdmissionControlResourcePercentageMemory'] = ha_admission_control_resource_percentage_memory

        if ha_admission_control_slot_policy_explicit_cpu and not isinstance(ha_admission_control_slot_policy_explicit_cpu, int):
            raise TypeError('Expected property ha_admission_control_slot_policy_explicit_cpu to be a int')
        __self__.ha_admission_control_slot_policy_explicit_cpu = ha_admission_control_slot_policy_explicit_cpu
        """
        Controls the
        user-defined CPU slot size, in MHz. Default: `32`.
        """
        __props__['haAdmissionControlSlotPolicyExplicitCpu'] = ha_admission_control_slot_policy_explicit_cpu

        if ha_admission_control_slot_policy_explicit_memory and not isinstance(ha_admission_control_slot_policy_explicit_memory, int):
            raise TypeError('Expected property ha_admission_control_slot_policy_explicit_memory to be a int')
        __self__.ha_admission_control_slot_policy_explicit_memory = ha_admission_control_slot_policy_explicit_memory
        """
        Controls the
        user-defined memory slot size, in MB. Default: `100`.
        """
        __props__['haAdmissionControlSlotPolicyExplicitMemory'] = ha_admission_control_slot_policy_explicit_memory

        if ha_admission_control_slot_policy_use_explicit_size and not isinstance(ha_admission_control_slot_policy_use_explicit_size, bool):
            raise TypeError('Expected property ha_admission_control_slot_policy_use_explicit_size to be a bool')
        __self__.ha_admission_control_slot_policy_use_explicit_size = ha_admission_control_slot_policy_use_explicit_size
        """
        Controls
        whether or not you wish to supply explicit values to CPU and memory slot
        sizes. The default is `false`, which tells vSphere to gather a automatic
        average based on all powered-on virtual machines currently in the cluster.
        """
        __props__['haAdmissionControlSlotPolicyUseExplicitSize'] = ha_admission_control_slot_policy_use_explicit_size

        if ha_advanced_options and not isinstance(ha_advanced_options, dict):
            raise TypeError('Expected property ha_advanced_options to be a dict')
        __self__.ha_advanced_options = ha_advanced_options
        """
        A key/value map that specifies advanced
        options for vSphere HA.
        """
        __props__['haAdvancedOptions'] = ha_advanced_options

        if ha_datastore_apd_recovery_action and not isinstance(ha_datastore_apd_recovery_action, basestring):
            raise TypeError('Expected property ha_datastore_apd_recovery_action to be a basestring')
        __self__.ha_datastore_apd_recovery_action = ha_datastore_apd_recovery_action
        """
        Controls the action to take
        on virtual machines if an APD status on an affected datastore clears in the
        middle of an APD event. Can be one of `none` or `reset`. Default: `none`.
        <sup>\*</sup>
        """
        __props__['haDatastoreApdRecoveryAction'] = ha_datastore_apd_recovery_action

        if ha_datastore_apd_response and not isinstance(ha_datastore_apd_response, basestring):
            raise TypeError('Expected property ha_datastore_apd_response to be a basestring')
        __self__.ha_datastore_apd_response = ha_datastore_apd_response
        """
        Controls the action to take on
        virtual machines when the cluster has detected loss to all paths to a
        relevant datastore. Can be one of `disabled`, `warning`,
        `restartConservative`, or `restartAggressive`.  Default: `disabled`.
        <sup>\*</sup>
        """
        __props__['haDatastoreApdResponse'] = ha_datastore_apd_response

        if ha_datastore_apd_response_delay and not isinstance(ha_datastore_apd_response_delay, int):
            raise TypeError('Expected property ha_datastore_apd_response_delay to be a int')
        __self__.ha_datastore_apd_response_delay = ha_datastore_apd_response_delay
        """
        Controls the delay in minutes
        to wait after an APD timeout event to execute the response action defined in
        `ha_datastore_apd_response`. Default: `3`
        minutes. <sup>\*</sup>
        """
        __props__['haDatastoreApdResponseDelay'] = ha_datastore_apd_response_delay

        if ha_datastore_pdl_response and not isinstance(ha_datastore_pdl_response, basestring):
            raise TypeError('Expected property ha_datastore_pdl_response to be a basestring')
        __self__.ha_datastore_pdl_response = ha_datastore_pdl_response
        """
        Controls the action to take on
        virtual machines when the cluster has detected a permanent device loss to a
        relevant datastore. Can be one of `disabled`, `warning`, or
        `restartAggressive`. Default: `disabled`.
        <sup>\*</sup>
        """
        __props__['haDatastorePdlResponse'] = ha_datastore_pdl_response

        if ha_enabled and not isinstance(ha_enabled, bool):
            raise TypeError('Expected property ha_enabled to be a bool')
        __self__.ha_enabled = ha_enabled
        """
        Enable vSphere HA for this cluster. Default:
        `false`.
        """
        __props__['haEnabled'] = ha_enabled

        if ha_heartbeat_datastore_ids and not isinstance(ha_heartbeat_datastore_ids, list):
            raise TypeError('Expected property ha_heartbeat_datastore_ids to be a list')
        __self__.ha_heartbeat_datastore_ids = ha_heartbeat_datastore_ids
        """
        The list of managed object IDs for
        preferred datastores to use for HA heartbeating. This setting is only useful
        when `ha_heartbeat_datastore_policy` is set
        to either `userSelectedDs` or `allFeasibleDsWithUserPreference`.
        """
        __props__['haHeartbeatDatastoreIds'] = ha_heartbeat_datastore_ids

        if ha_heartbeat_datastore_policy and not isinstance(ha_heartbeat_datastore_policy, basestring):
            raise TypeError('Expected property ha_heartbeat_datastore_policy to be a basestring')
        __self__.ha_heartbeat_datastore_policy = ha_heartbeat_datastore_policy
        """
        The selection policy for HA
        heartbeat datastores. Can be one of `allFeasibleDs`, `userSelectedDs`, or
        `allFeasibleDsWithUserPreference`. Default:
        `allFeasibleDsWithUserPreference`.
        """
        __props__['haHeartbeatDatastorePolicy'] = ha_heartbeat_datastore_policy

        if ha_host_isolation_response and not isinstance(ha_host_isolation_response, basestring):
            raise TypeError('Expected property ha_host_isolation_response to be a basestring')
        __self__.ha_host_isolation_response = ha_host_isolation_response
        """
        The action to take on virtual
        machines when a host has detected that it has been isolated from the rest of
        the cluster. Can be one of `none`, `powerOff`, or `shutdown`. Default:
        `none`.
        """
        __props__['haHostIsolationResponse'] = ha_host_isolation_response

        if ha_host_monitoring and not isinstance(ha_host_monitoring, basestring):
            raise TypeError('Expected property ha_host_monitoring to be a basestring')
        __self__.ha_host_monitoring = ha_host_monitoring
        """
        Global setting that controls whether
        vSphere HA remediates virtual machines on host failure. Can be one of `enabled`
        or `disabled`. Default: `enabled`.
        """
        __props__['haHostMonitoring'] = ha_host_monitoring

        if ha_vm_component_protection and not isinstance(ha_vm_component_protection, basestring):
            raise TypeError('Expected property ha_vm_component_protection to be a basestring')
        __self__.ha_vm_component_protection = ha_vm_component_protection
        """
        Controls vSphere VM component
        protection for virtual machines in this cluster. Can be one of `enabled` or
        `disabled`. Default: `enabled`.
        <sup>\*</sup>
        """
        __props__['haVmComponentProtection'] = ha_vm_component_protection

        if ha_vm_dependency_restart_condition and not isinstance(ha_vm_dependency_restart_condition, basestring):
            raise TypeError('Expected property ha_vm_dependency_restart_condition to be a basestring')
        __self__.ha_vm_dependency_restart_condition = ha_vm_dependency_restart_condition
        """
        The condition used to
        determine whether or not virtual machines in a certain restart priority class
        are online, allowing HA to move on to restarting virtual machines on the next
        priority. Can be one of `none`, `poweredOn`, `guestHbStatusGreen`, or
        `appHbStatusGreen`. The default is `none`, which means that a virtual machine
        is considered ready immediately after a host is found to start it on.
        <sup>\*</sup>
        """
        __props__['haVmDependencyRestartCondition'] = ha_vm_dependency_restart_condition

        if ha_vm_failure_interval and not isinstance(ha_vm_failure_interval, int):
            raise TypeError('Expected property ha_vm_failure_interval to be a int')
        __self__.ha_vm_failure_interval = ha_vm_failure_interval
        """
        If a heartbeat from a virtual machine
        is not received within this configured interval, the virtual machine is
        marked as failed. The value is in seconds. Default: `30`.
        """
        __props__['haVmFailureInterval'] = ha_vm_failure_interval

        if ha_vm_maximum_failure_window and not isinstance(ha_vm_maximum_failure_window, int):
            raise TypeError('Expected property ha_vm_maximum_failure_window to be a int')
        __self__.ha_vm_maximum_failure_window = ha_vm_maximum_failure_window
        """
        The length of the reset window in
        which `ha_vm_maximum_resets` can operate. When this
        window expires, no more resets are attempted regardless of the setting
        configured in `ha_vm_maximum_resets`. `-1` means no window, meaning an
        unlimited reset time is allotted. The value is specified in seconds. Default:
        `-1` (no window).
        """
        __props__['haVmMaximumFailureWindow'] = ha_vm_maximum_failure_window

        if ha_vm_maximum_resets and not isinstance(ha_vm_maximum_resets, int):
            raise TypeError('Expected property ha_vm_maximum_resets to be a int')
        __self__.ha_vm_maximum_resets = ha_vm_maximum_resets
        """
        The maximum number of resets that HA will
        perform to a virtual machine when responding to a failure event. Default: `3`
        """
        __props__['haVmMaximumResets'] = ha_vm_maximum_resets

        if ha_vm_minimum_uptime and not isinstance(ha_vm_minimum_uptime, int):
            raise TypeError('Expected property ha_vm_minimum_uptime to be a int')
        __self__.ha_vm_minimum_uptime = ha_vm_minimum_uptime
        """
        The time, in seconds, that HA waits after
        powering on a virtual machine before monitoring for heartbeats. Default:
        `120` (2 minutes).
        """
        __props__['haVmMinimumUptime'] = ha_vm_minimum_uptime

        if ha_vm_monitoring and not isinstance(ha_vm_monitoring, basestring):
            raise TypeError('Expected property ha_vm_monitoring to be a basestring')
        __self__.ha_vm_monitoring = ha_vm_monitoring
        """
        The type of virtual machine monitoring to use
        when HA is enabled in the cluster. Can be one of `vmMonitoringDisabled`,
        `vmMonitoringOnly`, or `vmAndAppMonitoring`. Default: `vmMonitoringDisabled`.
        """
        __props__['haVmMonitoring'] = ha_vm_monitoring

        if ha_vm_restart_additional_delay and not isinstance(ha_vm_restart_additional_delay, int):
            raise TypeError('Expected property ha_vm_restart_additional_delay to be a int')
        __self__.ha_vm_restart_additional_delay = ha_vm_restart_additional_delay
        """
        Additional delay in seconds
        after ready condition is met. A VM is considered ready at this point.
        Default: `0` (no delay). <sup>\*</sup>
        """
        __props__['haVmRestartAdditionalDelay'] = ha_vm_restart_additional_delay

        if ha_vm_restart_priority and not isinstance(ha_vm_restart_priority, basestring):
            raise TypeError('Expected property ha_vm_restart_priority to be a basestring')
        __self__.ha_vm_restart_priority = ha_vm_restart_priority
        """
        The default restart priority
        for affected virtual machines when vSphere detects a host failure. Can be one
        of `lowest`, `low`, `medium`, `high`, or `highest`. Default: `medium`.
        """
        __props__['haVmRestartPriority'] = ha_vm_restart_priority

        if ha_vm_restart_timeout and not isinstance(ha_vm_restart_timeout, int):
            raise TypeError('Expected property ha_vm_restart_timeout to be a int')
        __self__.ha_vm_restart_timeout = ha_vm_restart_timeout
        """
        The maximum time, in seconds,
        that vSphere HA will wait for virtual machines in one priority to be ready
        before proceeding with the next priority. Default: `600` (10 minutes).
        <sup>\*</sup>
        """
        __props__['haVmRestartTimeout'] = ha_vm_restart_timeout

        if host_cluster_exit_timeout and not isinstance(host_cluster_exit_timeout, int):
            raise TypeError('Expected property host_cluster_exit_timeout to be a int')
        __self__.host_cluster_exit_timeout = host_cluster_exit_timeout
        """
        The timeout for each host maintenance mode
        operation when removing hosts from a cluster. The value is specified in
        seconds. Default: `3600` (1 hour).
        """
        __props__['hostClusterExitTimeout'] = host_cluster_exit_timeout

        if host_system_ids and not isinstance(host_system_ids, list):
            raise TypeError('Expected property host_system_ids to be a list')
        __self__.host_system_ids = host_system_ids
        """
        The [managed object IDs][docs-about-morefs] of
        the hosts to put in the cluster.
        """
        __props__['hostSystemIds'] = host_system_ids

        if name and not isinstance(name, basestring):
            raise TypeError('Expected property name to be a basestring')
        __self__.name = name
        """
        The name of the cluster.
        """
        __props__['name'] = name

        if proactive_ha_automation_level and not isinstance(proactive_ha_automation_level, basestring):
            raise TypeError('Expected property proactive_ha_automation_level to be a basestring')
        __self__.proactive_ha_automation_level = proactive_ha_automation_level
        """
        Determines how the host
        quarantine, maintenance mode, or virtual machine migration recommendations
        made by proactive HA are to be handled. Can be one of `Automated` or
        `Manual`. Default: `Manual`. <sup>\*</sup>
        """
        __props__['proactiveHaAutomationLevel'] = proactive_ha_automation_level

        if proactive_ha_enabled and not isinstance(proactive_ha_enabled, bool):
            raise TypeError('Expected property proactive_ha_enabled to be a bool')
        __self__.proactive_ha_enabled = proactive_ha_enabled
        """
        Enables Proactive HA. Default: `false`.
        <sup>\*</sup>
        """
        __props__['proactiveHaEnabled'] = proactive_ha_enabled

        if proactive_ha_moderate_remediation and not isinstance(proactive_ha_moderate_remediation, basestring):
            raise TypeError('Expected property proactive_ha_moderate_remediation to be a basestring')
        __self__.proactive_ha_moderate_remediation = proactive_ha_moderate_remediation
        """
        The configured remediation
        for moderately degraded hosts. Can be one of `MaintenanceMode` or
        `QuarantineMode`. Note that this cannot be set to `MaintenanceMode` when
        `proactive_ha_severe_remediation` is set
        to `QuarantineMode`. Default: `QuarantineMode`.
        <sup>\*</sup>
        """
        __props__['proactiveHaModerateRemediation'] = proactive_ha_moderate_remediation

        if proactive_ha_provider_ids and not isinstance(proactive_ha_provider_ids, list):
            raise TypeError('Expected property proactive_ha_provider_ids to be a list')
        __self__.proactive_ha_provider_ids = proactive_ha_provider_ids
        """
        The list of IDs for health update
        providers configured for this cluster.
        <sup>\*</sup>
        """
        __props__['proactiveHaProviderIds'] = proactive_ha_provider_ids

        if proactive_ha_severe_remediation and not isinstance(proactive_ha_severe_remediation, basestring):
            raise TypeError('Expected property proactive_ha_severe_remediation to be a basestring')
        __self__.proactive_ha_severe_remediation = proactive_ha_severe_remediation
        """
        The configured remediation for
        severely degraded hosts. Can be one of `MaintenanceMode` or `QuarantineMode`.
        Note that this cannot be set to `QuarantineMode` when
        `proactive_ha_moderate_remediation` is
        set to `MaintenanceMode`. Default: `QuarantineMode`.
        <sup>\*</sup>
        """
        __props__['proactiveHaSevereRemediation'] = proactive_ha_severe_remediation

        if tags and not isinstance(tags, list):
            raise TypeError('Expected property tags to be a list')
        __self__.tags = tags
        """
        The IDs of any tags to attach to this resource. See
        [here][docs-applying-tags] for a reference on how to apply tags.
        """
        __props__['tags'] = tags

        __self__.resource_pool_id = pulumi.runtime.UNKNOWN
        """
        The managed object ID of the cluster's root resource pool.
        """

        super(ComputeCluster, __self__).__init__(
            'vsphere:index/computeCluster:ComputeCluster',
            __name__,
            __props__,
            __opts__)

    def set_outputs(self, outs):
        if 'customAttributes' in outs:
            self.custom_attributes = outs['customAttributes']
        if 'datacenterId' in outs:
            self.datacenter_id = outs['datacenterId']
        if 'dpmAutomationLevel' in outs:
            self.dpm_automation_level = outs['dpmAutomationLevel']
        if 'dpmEnabled' in outs:
            self.dpm_enabled = outs['dpmEnabled']
        if 'dpmThreshold' in outs:
            self.dpm_threshold = outs['dpmThreshold']
        if 'drsAdvancedOptions' in outs:
            self.drs_advanced_options = outs['drsAdvancedOptions']
        if 'drsAutomationLevel' in outs:
            self.drs_automation_level = outs['drsAutomationLevel']
        if 'drsEnablePredictiveDrs' in outs:
            self.drs_enable_predictive_drs = outs['drsEnablePredictiveDrs']
        if 'drsEnableVmOverrides' in outs:
            self.drs_enable_vm_overrides = outs['drsEnableVmOverrides']
        if 'drsEnabled' in outs:
            self.drs_enabled = outs['drsEnabled']
        if 'drsMigrationThreshold' in outs:
            self.drs_migration_threshold = outs['drsMigrationThreshold']
        if 'folder' in outs:
            self.folder = outs['folder']
        if 'forceEvacuateOnDestroy' in outs:
            self.force_evacuate_on_destroy = outs['forceEvacuateOnDestroy']
        if 'haAdmissionControlFailoverHostSystemIds' in outs:
            self.ha_admission_control_failover_host_system_ids = outs['haAdmissionControlFailoverHostSystemIds']
        if 'haAdmissionControlHostFailureTolerance' in outs:
            self.ha_admission_control_host_failure_tolerance = outs['haAdmissionControlHostFailureTolerance']
        if 'haAdmissionControlPerformanceTolerance' in outs:
            self.ha_admission_control_performance_tolerance = outs['haAdmissionControlPerformanceTolerance']
        if 'haAdmissionControlPolicy' in outs:
            self.ha_admission_control_policy = outs['haAdmissionControlPolicy']
        if 'haAdmissionControlResourcePercentageAutoCompute' in outs:
            self.ha_admission_control_resource_percentage_auto_compute = outs['haAdmissionControlResourcePercentageAutoCompute']
        if 'haAdmissionControlResourcePercentageCpu' in outs:
            self.ha_admission_control_resource_percentage_cpu = outs['haAdmissionControlResourcePercentageCpu']
        if 'haAdmissionControlResourcePercentageMemory' in outs:
            self.ha_admission_control_resource_percentage_memory = outs['haAdmissionControlResourcePercentageMemory']
        if 'haAdmissionControlSlotPolicyExplicitCpu' in outs:
            self.ha_admission_control_slot_policy_explicit_cpu = outs['haAdmissionControlSlotPolicyExplicitCpu']
        if 'haAdmissionControlSlotPolicyExplicitMemory' in outs:
            self.ha_admission_control_slot_policy_explicit_memory = outs['haAdmissionControlSlotPolicyExplicitMemory']
        if 'haAdmissionControlSlotPolicyUseExplicitSize' in outs:
            self.ha_admission_control_slot_policy_use_explicit_size = outs['haAdmissionControlSlotPolicyUseExplicitSize']
        if 'haAdvancedOptions' in outs:
            self.ha_advanced_options = outs['haAdvancedOptions']
        if 'haDatastoreApdRecoveryAction' in outs:
            self.ha_datastore_apd_recovery_action = outs['haDatastoreApdRecoveryAction']
        if 'haDatastoreApdResponse' in outs:
            self.ha_datastore_apd_response = outs['haDatastoreApdResponse']
        if 'haDatastoreApdResponseDelay' in outs:
            self.ha_datastore_apd_response_delay = outs['haDatastoreApdResponseDelay']
        if 'haDatastorePdlResponse' in outs:
            self.ha_datastore_pdl_response = outs['haDatastorePdlResponse']
        if 'haEnabled' in outs:
            self.ha_enabled = outs['haEnabled']
        if 'haHeartbeatDatastoreIds' in outs:
            self.ha_heartbeat_datastore_ids = outs['haHeartbeatDatastoreIds']
        if 'haHeartbeatDatastorePolicy' in outs:
            self.ha_heartbeat_datastore_policy = outs['haHeartbeatDatastorePolicy']
        if 'haHostIsolationResponse' in outs:
            self.ha_host_isolation_response = outs['haHostIsolationResponse']
        if 'haHostMonitoring' in outs:
            self.ha_host_monitoring = outs['haHostMonitoring']
        if 'haVmComponentProtection' in outs:
            self.ha_vm_component_protection = outs['haVmComponentProtection']
        if 'haVmDependencyRestartCondition' in outs:
            self.ha_vm_dependency_restart_condition = outs['haVmDependencyRestartCondition']
        if 'haVmFailureInterval' in outs:
            self.ha_vm_failure_interval = outs['haVmFailureInterval']
        if 'haVmMaximumFailureWindow' in outs:
            self.ha_vm_maximum_failure_window = outs['haVmMaximumFailureWindow']
        if 'haVmMaximumResets' in outs:
            self.ha_vm_maximum_resets = outs['haVmMaximumResets']
        if 'haVmMinimumUptime' in outs:
            self.ha_vm_minimum_uptime = outs['haVmMinimumUptime']
        if 'haVmMonitoring' in outs:
            self.ha_vm_monitoring = outs['haVmMonitoring']
        if 'haVmRestartAdditionalDelay' in outs:
            self.ha_vm_restart_additional_delay = outs['haVmRestartAdditionalDelay']
        if 'haVmRestartPriority' in outs:
            self.ha_vm_restart_priority = outs['haVmRestartPriority']
        if 'haVmRestartTimeout' in outs:
            self.ha_vm_restart_timeout = outs['haVmRestartTimeout']
        if 'hostClusterExitTimeout' in outs:
            self.host_cluster_exit_timeout = outs['hostClusterExitTimeout']
        if 'hostSystemIds' in outs:
            self.host_system_ids = outs['hostSystemIds']
        if 'name' in outs:
            self.name = outs['name']
        if 'proactiveHaAutomationLevel' in outs:
            self.proactive_ha_automation_level = outs['proactiveHaAutomationLevel']
        if 'proactiveHaEnabled' in outs:
            self.proactive_ha_enabled = outs['proactiveHaEnabled']
        if 'proactiveHaModerateRemediation' in outs:
            self.proactive_ha_moderate_remediation = outs['proactiveHaModerateRemediation']
        if 'proactiveHaProviderIds' in outs:
            self.proactive_ha_provider_ids = outs['proactiveHaProviderIds']
        if 'proactiveHaSevereRemediation' in outs:
            self.proactive_ha_severe_remediation = outs['proactiveHaSevereRemediation']
        if 'resourcePoolId' in outs:
            self.resource_pool_id = outs['resourcePoolId']
        if 'tags' in outs:
            self.tags = outs['tags']
