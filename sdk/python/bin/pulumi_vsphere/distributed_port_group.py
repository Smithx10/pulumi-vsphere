# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import pulumi
import pulumi.runtime

class DistributedPortGroup(pulumi.CustomResource):
    """
    The `vsphere_distributed_port_group` resource can be used to manage vSphere
    distributed virtual port groups. These port groups are connected to distributed
    virtual switches, which can be managed by the
    [`vsphere_distributed_virtual_switch`][distributed-virtual-switch] resource.
    
    Distributed port groups can be used as networks for virtual machines, allowing
    VMs to use the networking supplied by a distributed virtual switch (DVS), with
    a set of policies that apply to that individual newtork, if desired.
    
    For an overview on vSphere networking concepts, see [this
    page][ref-vsphere-net-concepts]. For more information on vSphere DVS
    portgroups, see [this page][ref-vsphere-dvportgroup].
    
    [distributed-virtual-switch]: /docs/providers/vsphere/r/distributed_virtual_switch.html
    [ref-vsphere-net-concepts]: https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.networking.doc/GUID-2B11DBB8-CB3C-4AFF-8885-EFEA0FC562F4.html
    [ref-vsphere-dvportgroup]: https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.networking.doc/GUID-69933F6E-2442-46CF-AA17-1196CB9A0A09.html
    
    ~> **NOTE:** This resource requires vCenter and is not available on direct ESXi
    connections.
    """
    def __init__(__self__, __name__, __opts__=None, active_uplinks=None, allow_forged_transmits=None, allow_mac_changes=None, allow_promiscuous=None, auto_expand=None, block_all_ports=None, block_override_allowed=None, check_beacon=None, custom_attributes=None, description=None, directpath_gen2_allowed=None, distributed_virtual_switch_uuid=None, egress_shaping_average_bandwidth=None, egress_shaping_burst_size=None, egress_shaping_enabled=None, egress_shaping_peak_bandwidth=None, failback=None, ingress_shaping_average_bandwidth=None, ingress_shaping_burst_size=None, ingress_shaping_enabled=None, ingress_shaping_peak_bandwidth=None, lacp_enabled=None, lacp_mode=None, live_port_moving_allowed=None, name=None, netflow_enabled=None, netflow_override_allowed=None, network_resource_pool_key=None, network_resource_pool_override_allowed=None, notify_switches=None, number_of_ports=None, port_config_reset_at_disconnect=None, port_name_format=None, port_private_secondary_vlan_id=None, security_policy_override_allowed=None, shaping_override_allowed=None, standby_uplinks=None, tags=None, teaming_policy=None, traffic_filter_override_allowed=None, tx_uplink=None, type=None, uplink_teaming_override_allowed=None, vlan_id=None, vlan_override_allowed=None, vlan_ranges=None):
        """Create a DistributedPortGroup resource with the given unique name, props, and options."""
        if not __name__:
            raise TypeError('Missing resource name argument (for URN creation)')
        if not isinstance(__name__, basestring):
            raise TypeError('Expected resource name to be a string')
        if __opts__ and not isinstance(__opts__, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')

        __props__ = dict()

        if active_uplinks and not isinstance(active_uplinks, list):
            raise TypeError('Expected property active_uplinks to be a list')
        __self__.active_uplinks = active_uplinks
        """
        List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
        """
        __props__['activeUplinks'] = active_uplinks

        if allow_forged_transmits and not isinstance(allow_forged_transmits, bool):
            raise TypeError('Expected property allow_forged_transmits to be a bool')
        __self__.allow_forged_transmits = allow_forged_transmits
        """
        Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC
        address than that of its own.
        """
        __props__['allowForgedTransmits'] = allow_forged_transmits

        if allow_mac_changes and not isinstance(allow_mac_changes, bool):
            raise TypeError('Expected property allow_mac_changes to be a bool')
        __self__.allow_mac_changes = allow_mac_changes
        """
        Controls whether or not the Media Access Control (MAC) address can be changed.
        """
        __props__['allowMacChanges'] = allow_mac_changes

        if allow_promiscuous and not isinstance(allow_promiscuous, bool):
            raise TypeError('Expected property allow_promiscuous to be a bool')
        __self__.allow_promiscuous = allow_promiscuous
        """
        Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.
        """
        __props__['allowPromiscuous'] = allow_promiscuous

        if auto_expand and not isinstance(auto_expand, bool):
            raise TypeError('Expected property auto_expand to be a bool')
        __self__.auto_expand = auto_expand
        """
        Allows the port group to create additional ports
        past the limit specified in `number_of_ports` if necessary. Default: `true`.
        """
        __props__['autoExpand'] = auto_expand

        if block_all_ports and not isinstance(block_all_ports, bool):
            raise TypeError('Expected property block_all_ports to be a bool')
        __self__.block_all_ports = block_all_ports
        """
        Indicates whether to block all ports by default.
        """
        __props__['blockAllPorts'] = block_all_ports

        if block_override_allowed and not isinstance(block_override_allowed, bool):
            raise TypeError('Expected property block_override_allowed to be a bool')
        __self__.block_override_allowed = block_override_allowed
        """
        Allow the [port shutdown
        policy][port-shutdown-policy] to be overridden on an individual port.
        """
        __props__['blockOverrideAllowed'] = block_override_allowed

        if check_beacon and not isinstance(check_beacon, bool):
            raise TypeError('Expected property check_beacon to be a bool')
        __self__.check_beacon = check_beacon
        """
        Enable beacon probing on the ports this policy applies to.
        """
        __props__['checkBeacon'] = check_beacon

        if custom_attributes and not isinstance(custom_attributes, dict):
            raise TypeError('Expected property custom_attributes to be a dict')
        __self__.custom_attributes = custom_attributes
        """
        Map of custom attribute ids to attribute
        value string to set for port group. See [here][docs-setting-custom-attributes]
        for a reference on how to set values for custom attributes.
        """
        __props__['customAttributes'] = custom_attributes

        if description and not isinstance(description, basestring):
            raise TypeError('Expected property description to be a basestring')
        __self__.description = description
        """
        An optional description for the port group.
        """
        __props__['description'] = description

        if directpath_gen2_allowed and not isinstance(directpath_gen2_allowed, bool):
            raise TypeError('Expected property directpath_gen2_allowed to be a bool')
        __self__.directpath_gen2_allowed = directpath_gen2_allowed
        """
        Allow VMDirectPath Gen2 on the ports this policy applies to.
        """
        __props__['directpathGen2Allowed'] = directpath_gen2_allowed

        if not distributed_virtual_switch_uuid:
            raise TypeError('Missing required property distributed_virtual_switch_uuid')
        elif not isinstance(distributed_virtual_switch_uuid, basestring):
            raise TypeError('Expected property distributed_virtual_switch_uuid to be a basestring')
        __self__.distributed_virtual_switch_uuid = distributed_virtual_switch_uuid
        """
        The ID of the DVS to add the
        port group to. Forces a new resource if changed.
        """
        __props__['distributedVirtualSwitchUuid'] = distributed_virtual_switch_uuid

        if egress_shaping_average_bandwidth and not isinstance(egress_shaping_average_bandwidth, int):
            raise TypeError('Expected property egress_shaping_average_bandwidth to be a int')
        __self__.egress_shaping_average_bandwidth = egress_shaping_average_bandwidth
        """
        The average egress bandwidth in bits per second if egress shaping is enabled on the port.
        """
        __props__['egressShapingAverageBandwidth'] = egress_shaping_average_bandwidth

        if egress_shaping_burst_size and not isinstance(egress_shaping_burst_size, int):
            raise TypeError('Expected property egress_shaping_burst_size to be a int')
        __self__.egress_shaping_burst_size = egress_shaping_burst_size
        """
        The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.
        """
        __props__['egressShapingBurstSize'] = egress_shaping_burst_size

        if egress_shaping_enabled and not isinstance(egress_shaping_enabled, bool):
            raise TypeError('Expected property egress_shaping_enabled to be a bool')
        __self__.egress_shaping_enabled = egress_shaping_enabled
        """
        True if the traffic shaper is enabled for egress traffic on the port.
        """
        __props__['egressShapingEnabled'] = egress_shaping_enabled

        if egress_shaping_peak_bandwidth and not isinstance(egress_shaping_peak_bandwidth, int):
            raise TypeError('Expected property egress_shaping_peak_bandwidth to be a int')
        __self__.egress_shaping_peak_bandwidth = egress_shaping_peak_bandwidth
        """
        The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.
        """
        __props__['egressShapingPeakBandwidth'] = egress_shaping_peak_bandwidth

        if failback and not isinstance(failback, bool):
            raise TypeError('Expected property failback to be a bool')
        __self__.failback = failback
        """
        If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.
        """
        __props__['failback'] = failback

        if ingress_shaping_average_bandwidth and not isinstance(ingress_shaping_average_bandwidth, int):
            raise TypeError('Expected property ingress_shaping_average_bandwidth to be a int')
        __self__.ingress_shaping_average_bandwidth = ingress_shaping_average_bandwidth
        """
        The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.
        """
        __props__['ingressShapingAverageBandwidth'] = ingress_shaping_average_bandwidth

        if ingress_shaping_burst_size and not isinstance(ingress_shaping_burst_size, int):
            raise TypeError('Expected property ingress_shaping_burst_size to be a int')
        __self__.ingress_shaping_burst_size = ingress_shaping_burst_size
        """
        The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.
        """
        __props__['ingressShapingBurstSize'] = ingress_shaping_burst_size

        if ingress_shaping_enabled and not isinstance(ingress_shaping_enabled, bool):
            raise TypeError('Expected property ingress_shaping_enabled to be a bool')
        __self__.ingress_shaping_enabled = ingress_shaping_enabled
        """
        True if the traffic shaper is enabled for ingress traffic on the port.
        """
        __props__['ingressShapingEnabled'] = ingress_shaping_enabled

        if ingress_shaping_peak_bandwidth and not isinstance(ingress_shaping_peak_bandwidth, int):
            raise TypeError('Expected property ingress_shaping_peak_bandwidth to be a int')
        __self__.ingress_shaping_peak_bandwidth = ingress_shaping_peak_bandwidth
        """
        The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.
        """
        __props__['ingressShapingPeakBandwidth'] = ingress_shaping_peak_bandwidth

        if lacp_enabled and not isinstance(lacp_enabled, bool):
            raise TypeError('Expected property lacp_enabled to be a bool')
        __self__.lacp_enabled = lacp_enabled
        """
        Whether or not to enable LACP on all uplink ports.
        """
        __props__['lacpEnabled'] = lacp_enabled

        if lacp_mode and not isinstance(lacp_mode, basestring):
            raise TypeError('Expected property lacp_mode to be a basestring')
        __self__.lacp_mode = lacp_mode
        """
        The uplink LACP mode to use. Can be one of active or passive.
        """
        __props__['lacpMode'] = lacp_mode

        if live_port_moving_allowed and not isinstance(live_port_moving_allowed, bool):
            raise TypeError('Expected property live_port_moving_allowed to be a bool')
        __self__.live_port_moving_allowed = live_port_moving_allowed
        """
        Allow a port in this port group to be
        moved to another port group while it is connected.
        """
        __props__['livePortMovingAllowed'] = live_port_moving_allowed

        if name and not isinstance(name, basestring):
            raise TypeError('Expected property name to be a basestring')
        __self__.name = name
        """
        The name of the port group.
        """
        __props__['name'] = name

        if netflow_enabled and not isinstance(netflow_enabled, bool):
            raise TypeError('Expected property netflow_enabled to be a bool')
        __self__.netflow_enabled = netflow_enabled
        """
        Indicates whether to enable netflow on all ports.
        """
        __props__['netflowEnabled'] = netflow_enabled

        if netflow_override_allowed and not isinstance(netflow_override_allowed, bool):
            raise TypeError('Expected property netflow_override_allowed to be a bool')
        __self__.netflow_override_allowed = netflow_override_allowed
        """
        Allow the [Netflow
        policy][netflow-policy] on this port group to be overridden on an individual
        port.
        """
        __props__['netflowOverrideAllowed'] = netflow_override_allowed

        if network_resource_pool_key and not isinstance(network_resource_pool_key, basestring):
            raise TypeError('Expected property network_resource_pool_key to be a basestring')
        __self__.network_resource_pool_key = network_resource_pool_key
        """
        The key of a network resource pool
        to associate with this port group. The default is `-1`, which implies no
        association.
        """
        __props__['networkResourcePoolKey'] = network_resource_pool_key

        if network_resource_pool_override_allowed and not isinstance(network_resource_pool_override_allowed, bool):
            raise TypeError('Expected property network_resource_pool_override_allowed to be a bool')
        __self__.network_resource_pool_override_allowed = network_resource_pool_override_allowed
        """
        Allow the network
        resource pool set on this port group to be overridden on an individual port.
        """
        __props__['networkResourcePoolOverrideAllowed'] = network_resource_pool_override_allowed

        if notify_switches and not isinstance(notify_switches, bool):
            raise TypeError('Expected property notify_switches to be a bool')
        __self__.notify_switches = notify_switches
        """
        If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.
        """
        __props__['notifySwitches'] = notify_switches

        if number_of_ports and not isinstance(number_of_ports, int):
            raise TypeError('Expected property number_of_ports to be a int')
        __self__.number_of_ports = number_of_ports
        """
        The number of ports available on this port
        group. Cannot be decreased below the amount of used ports on the port group.
        """
        __props__['numberOfPorts'] = number_of_ports

        if port_config_reset_at_disconnect and not isinstance(port_config_reset_at_disconnect, bool):
            raise TypeError('Expected property port_config_reset_at_disconnect to be a bool')
        __self__.port_config_reset_at_disconnect = port_config_reset_at_disconnect
        """
        Reset a port's settings to the
        settings defined on this port group policy when the port disconnects.
        """
        __props__['portConfigResetAtDisconnect'] = port_config_reset_at_disconnect

        if port_name_format and not isinstance(port_name_format, basestring):
            raise TypeError('Expected property port_name_format to be a basestring')
        __self__.port_name_format = port_name_format
        """
        An optional formatting policy for naming of
        the ports in this port group. See the `portNameFormat` attribute listed
        [here][ext-vsphere-portname-format] for details on the format syntax.
        """
        __props__['portNameFormat'] = port_name_format

        if port_private_secondary_vlan_id and not isinstance(port_private_secondary_vlan_id, int):
            raise TypeError('Expected property port_private_secondary_vlan_id to be a int')
        __self__.port_private_secondary_vlan_id = port_private_secondary_vlan_id
        """
        The secondary VLAN ID for this port.
        """
        __props__['portPrivateSecondaryVlanId'] = port_private_secondary_vlan_id

        if security_policy_override_allowed and not isinstance(security_policy_override_allowed, bool):
            raise TypeError('Expected property security_policy_override_allowed to be a bool')
        __self__.security_policy_override_allowed = security_policy_override_allowed
        """
        Allow the [security policy
        settings][sec-policy-settings] defined in this port group policy to be
        overridden on an individual port.
        """
        __props__['securityPolicyOverrideAllowed'] = security_policy_override_allowed

        if shaping_override_allowed and not isinstance(shaping_override_allowed, bool):
            raise TypeError('Expected property shaping_override_allowed to be a bool')
        __self__.shaping_override_allowed = shaping_override_allowed
        """
        Allow the [traffic shaping
        options][traffic-shaping-settings] on this port group policy to be overridden
        on an individual port.
        """
        __props__['shapingOverrideAllowed'] = shaping_override_allowed

        if standby_uplinks and not isinstance(standby_uplinks, list):
            raise TypeError('Expected property standby_uplinks to be a list')
        __self__.standby_uplinks = standby_uplinks
        """
        List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
        """
        __props__['standbyUplinks'] = standby_uplinks

        if tags and not isinstance(tags, list):
            raise TypeError('Expected property tags to be a list')
        __self__.tags = tags
        """
        A list of tag IDs to apply to this object.
        """
        __props__['tags'] = tags

        if teaming_policy and not isinstance(teaming_policy, basestring):
            raise TypeError('Expected property teaming_policy to be a basestring')
        __self__.teaming_policy = teaming_policy
        """
        The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid,
        failover_explicit, or loadbalance_loadbased.
        """
        __props__['teamingPolicy'] = teaming_policy

        if traffic_filter_override_allowed and not isinstance(traffic_filter_override_allowed, bool):
            raise TypeError('Expected property traffic_filter_override_allowed to be a bool')
        __self__.traffic_filter_override_allowed = traffic_filter_override_allowed
        """
        Allow any traffic filters on
        this port group to be overridden on an individual port.
        """
        __props__['trafficFilterOverrideAllowed'] = traffic_filter_override_allowed

        if tx_uplink and not isinstance(tx_uplink, bool):
            raise TypeError('Expected property tx_uplink to be a bool')
        __self__.tx_uplink = tx_uplink
        """
        If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular
        packet forwarded done by the switch.
        """
        __props__['txUplink'] = tx_uplink

        if type and not isinstance(type, basestring):
            raise TypeError('Expected property type to be a basestring')
        __self__.type = type
        """
        The port group type. Can be one of `earlyBinding` (static
        binding) or `ephemeral`. Default: `earlyBinding`.
        """
        __props__['type'] = type

        if uplink_teaming_override_allowed and not isinstance(uplink_teaming_override_allowed, bool):
            raise TypeError('Expected property uplink_teaming_override_allowed to be a bool')
        __self__.uplink_teaming_override_allowed = uplink_teaming_override_allowed
        """
        Allow the [uplink teaming
        options][uplink-teaming-settings] on this port group to be overridden on an
        individual port.
        """
        __props__['uplinkTeamingOverrideAllowed'] = uplink_teaming_override_allowed

        if vlan_id and not isinstance(vlan_id, int):
            raise TypeError('Expected property vlan_id to be a int')
        __self__.vlan_id = vlan_id
        """
        The VLAN ID for single VLAN mode. 0 denotes no VLAN.
        """
        __props__['vlanId'] = vlan_id

        if vlan_override_allowed and not isinstance(vlan_override_allowed, bool):
            raise TypeError('Expected property vlan_override_allowed to be a bool')
        __self__.vlan_override_allowed = vlan_override_allowed
        """
        Allow the [VLAN settings][vlan-settings]
        on this port group to be overridden on an individual port.
        """
        __props__['vlanOverrideAllowed'] = vlan_override_allowed

        if vlan_ranges and not isinstance(vlan_ranges, list):
            raise TypeError('Expected property vlan_ranges to be a list')
        __self__.vlan_ranges = vlan_ranges
        """
        The VLAN ID for single VLAN mode. 0 denotes no VLAN.
        """
        __props__['vlanRanges'] = vlan_ranges

        __self__.config_version = pulumi.runtime.UNKNOWN
        """
        Version string of the configuration that this spec is trying to change.
        """
        __self__.key = pulumi.runtime.UNKNOWN
        """
        The generated UUID of the portgroup.
        """

        super(DistributedPortGroup, __self__).__init__(
            'vsphere:index/distributedPortGroup:DistributedPortGroup',
            __name__,
            __props__,
            __opts__)

    def set_outputs(self, outs):
        if 'activeUplinks' in outs:
            self.active_uplinks = outs['activeUplinks']
        if 'allowForgedTransmits' in outs:
            self.allow_forged_transmits = outs['allowForgedTransmits']
        if 'allowMacChanges' in outs:
            self.allow_mac_changes = outs['allowMacChanges']
        if 'allowPromiscuous' in outs:
            self.allow_promiscuous = outs['allowPromiscuous']
        if 'autoExpand' in outs:
            self.auto_expand = outs['autoExpand']
        if 'blockAllPorts' in outs:
            self.block_all_ports = outs['blockAllPorts']
        if 'blockOverrideAllowed' in outs:
            self.block_override_allowed = outs['blockOverrideAllowed']
        if 'checkBeacon' in outs:
            self.check_beacon = outs['checkBeacon']
        if 'configVersion' in outs:
            self.config_version = outs['configVersion']
        if 'customAttributes' in outs:
            self.custom_attributes = outs['customAttributes']
        if 'description' in outs:
            self.description = outs['description']
        if 'directpathGen2Allowed' in outs:
            self.directpath_gen2_allowed = outs['directpathGen2Allowed']
        if 'distributedVirtualSwitchUuid' in outs:
            self.distributed_virtual_switch_uuid = outs['distributedVirtualSwitchUuid']
        if 'egressShapingAverageBandwidth' in outs:
            self.egress_shaping_average_bandwidth = outs['egressShapingAverageBandwidth']
        if 'egressShapingBurstSize' in outs:
            self.egress_shaping_burst_size = outs['egressShapingBurstSize']
        if 'egressShapingEnabled' in outs:
            self.egress_shaping_enabled = outs['egressShapingEnabled']
        if 'egressShapingPeakBandwidth' in outs:
            self.egress_shaping_peak_bandwidth = outs['egressShapingPeakBandwidth']
        if 'failback' in outs:
            self.failback = outs['failback']
        if 'ingressShapingAverageBandwidth' in outs:
            self.ingress_shaping_average_bandwidth = outs['ingressShapingAverageBandwidth']
        if 'ingressShapingBurstSize' in outs:
            self.ingress_shaping_burst_size = outs['ingressShapingBurstSize']
        if 'ingressShapingEnabled' in outs:
            self.ingress_shaping_enabled = outs['ingressShapingEnabled']
        if 'ingressShapingPeakBandwidth' in outs:
            self.ingress_shaping_peak_bandwidth = outs['ingressShapingPeakBandwidth']
        if 'key' in outs:
            self.key = outs['key']
        if 'lacpEnabled' in outs:
            self.lacp_enabled = outs['lacpEnabled']
        if 'lacpMode' in outs:
            self.lacp_mode = outs['lacpMode']
        if 'livePortMovingAllowed' in outs:
            self.live_port_moving_allowed = outs['livePortMovingAllowed']
        if 'name' in outs:
            self.name = outs['name']
        if 'netflowEnabled' in outs:
            self.netflow_enabled = outs['netflowEnabled']
        if 'netflowOverrideAllowed' in outs:
            self.netflow_override_allowed = outs['netflowOverrideAllowed']
        if 'networkResourcePoolKey' in outs:
            self.network_resource_pool_key = outs['networkResourcePoolKey']
        if 'networkResourcePoolOverrideAllowed' in outs:
            self.network_resource_pool_override_allowed = outs['networkResourcePoolOverrideAllowed']
        if 'notifySwitches' in outs:
            self.notify_switches = outs['notifySwitches']
        if 'numberOfPorts' in outs:
            self.number_of_ports = outs['numberOfPorts']
        if 'portConfigResetAtDisconnect' in outs:
            self.port_config_reset_at_disconnect = outs['portConfigResetAtDisconnect']
        if 'portNameFormat' in outs:
            self.port_name_format = outs['portNameFormat']
        if 'portPrivateSecondaryVlanId' in outs:
            self.port_private_secondary_vlan_id = outs['portPrivateSecondaryVlanId']
        if 'securityPolicyOverrideAllowed' in outs:
            self.security_policy_override_allowed = outs['securityPolicyOverrideAllowed']
        if 'shapingOverrideAllowed' in outs:
            self.shaping_override_allowed = outs['shapingOverrideAllowed']
        if 'standbyUplinks' in outs:
            self.standby_uplinks = outs['standbyUplinks']
        if 'tags' in outs:
            self.tags = outs['tags']
        if 'teamingPolicy' in outs:
            self.teaming_policy = outs['teamingPolicy']
        if 'trafficFilterOverrideAllowed' in outs:
            self.traffic_filter_override_allowed = outs['trafficFilterOverrideAllowed']
        if 'txUplink' in outs:
            self.tx_uplink = outs['txUplink']
        if 'type' in outs:
            self.type = outs['type']
        if 'uplinkTeamingOverrideAllowed' in outs:
            self.uplink_teaming_override_allowed = outs['uplinkTeamingOverrideAllowed']
        if 'vlanId' in outs:
            self.vlan_id = outs['vlanId']
        if 'vlanOverrideAllowed' in outs:
            self.vlan_override_allowed = outs['vlanOverrideAllowed']
        if 'vlanRanges' in outs:
            self.vlan_ranges = outs['vlanRanges']
